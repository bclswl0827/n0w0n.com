{"title":"ChatGemini - 一款博主开发的山寨版 ChatGPT","created_at":1707224280000,"updated_at":1708061369913,"content":"\n博主前些日子逛 V2EX 时，经常看到有人讨论各种 ChatGPT 的第三方客户端。作为一个月月被 ChatGPT-4 爆金币的人，自然对这些第三方客户端没有兴趣~~（毕竟咱可是高贵的官方用户）~~。直到 Google 发布了 Gemini 模型后，博主才想要体验一下这个 AI 模型到底有多厉害，于是在 GitHub 上搜索起了 Gemini 的第三方客户端。\n\n![1](https://c.ibcl.us/Gemini-Client_20240206/1.png)\n\n好家伙，第一条结果的 `babaohuang/GeminiProChat` 居然有 3.5k 颗 Star，看来这个客户端还是挺受欢迎的，可顺着仓库给出的演示 URL 进去，结果却让博主大失所望。\n\n![2](https://c.ibcl.us/Gemini-Client_20240206/2.png)\n\n这套客户端没有历史记录，发出去的消息也不能再编辑，**另外 Gemini 很重要的识图功能居然也没有实现**，这怎么能行？\n\n鉴于以上种种不好的使用体验，因此博主最后决定自己开发一个山寨版的 ChatGPT 客户端，名字就叫 ChatGemini。\n\n说干就干，博主花了 3 天时间，用 React + TypeScript + TailwindCSS 打造了出一款全新的，有如下功能的 Gemini 客户端，项目一经发布，截止博主写这篇文章时，已经收获了 470 颗 Star。\n\n - 适配移动端\n - 支持多 API 密钥分流\n - 操作逻辑同 ChatGPT\n - 仿 ChatGPT 3.5 界面\n - 支持多轮聊天对话\n - 支持上传图片进行识别\n - 逐字输出（SSE）回应\n - 集成 PHP 版反向代理\n - 自定义 Gemini API 地址\n - 可启用站点通行码防止滥用\n - 聊天内容导出（HTML 和 PDF）\n - 对话内容保存在 IndexedDB 中\n - 在 AI 回应中运行 Python 代码\n\n![3](https://c.ibcl.us/Gemini-Client_20240206/3.png)\n\n这篇文章并不打算将 README 中的内容再复述一遍，因此这里只会记录一些博主在开发过程中的细节。\n\n\n\n## 项目介绍\n\n这是一个基于 Google Gemini 的网页客户端，对标 ChatGPT 3.5，使用逻辑同 ChatGPT 3.5 一致，同时支持在聊天中上传图片，自动调用 Gemini-Pro-Vision 模型进行识图。\n\n这个项目还可自定义 Gemini API 服务器地址，用户可将本项目部署至支持 PHP 的服务器或虚拟主机上，或是自行配置 Nginx 反向代理，透过修改 Gemini API 路径，从而在中国大陆无障碍使用。\n\n项目地址：[bclswl0827/ChatGemini](https://github.com/bclswl0827/ChatGemini)\n\n## 框架选型\n\n博主在看了其他几个第三方 ChatGPT 客户端的代码后，发现有的项目使用了 Next.js，但博主并不打算使用 SSR 方式，因此还是选择了 React + TypeScript 方案。选择 React 也是因为博主对 React 更熟悉，另外，React 也是目前最流行的前端框架之一。\n\n另外，博主还使用了 TailwindCSS，这是一个 CSS 框架，它的特点是不需要写 CSS，只需要在 HTML 中使用类名即可，这样可以大大减少 CSS 的编写量，另外，这款框架也用在了博主的另外一个项目 [AnyShake Observer](https://github.com/anyshake/observer) 中。\n\n## 配置文件\n\n项目中有一些需要部署时配置的参数，比如 Gemini API Key、站点通行码等，这些参数都是通过配置文件进行管理的。博主将这些参数放在了 `.env` 文件中，这样在构建部署时，只需要修改这个文件即可。\n\n|           配置项           | 必填 | 可选值               | 默认值       | 说明                                     | 备注                                       |\n| :------------------------: | :--- | :------------------- | :----------- | :--------------------------------------- | :----------------------------------------- |\n| `REACT_APP_GEMINI_API_KEY` | 是   | `string`\\|`string[]` | 空           | 填入 Gemini API 密钥，多个以 `\\|` 分隔   | 存在多个密钥时，每次应用加载时随机选用一个 |\n| `REACT_APP_GEMINI_API_URL` | 否   | `string`             | 空           | 自定义 Gemini API 地址，用于反向代理     | 无                                         |\n| `REACT_APP_GEMINI_API_SSE` | 否   | `true`\\|`false`      | `true`       | 是否逐字输出 Gemini 回应，即是否使能 SSE | 无                                         |\n|   `REACT_APP_TITLE_SITE`   | 否   | `string`             | `ChatGemini` | 站点标题，将显示在浏览器标签页上         | 无                                         |\n|  `REACT_APP_TITLE_HEADER`  | 否   | `string`             | `Gemini Pro` | 应用标题，显示在应用侧边栏和头部         | 无                                         |\n|  `REACT_APP_PASSCODE_MD5`  | 否   | `string`\\|`string[]` | 空           | MD5 格式通行码，多个以 `\\|` 分隔         | 存在多个通行码时，任意一个通过验证即可登入 |\n\n但是博主在后期对项目进行 Docker 打包时，才发现依赖 `.env` 文件进行应用配置并不是一个好的选择，因为对 `.env` 文件进行修改后，需要重新构建整个 React 应用才能生效。\n\n而要临时解决这个问题，只能在每次应用启动时都执行 `npm run build` 命令，生成最新的版本，然后再启动 Nginx 服务。但是这样会导致镜像体积剧增，同时应用启动时间也会变长，并不利于应用的持续部署。博主当时的 `entrypoint.sh` 长下面这样。\n\n```shell\n#!/bin/sh\n\nif [ -z \"${REACT_APP_GEMINI_API_KEY}\" ]; then\n    echo \"env REACT_APP_GEMINI_API_KEY is unset or set to the empty string\"\n    exit 1\nfi\n\ncat << EOF > .env\nREACT_APP_TITLE_SITE=\"${REACT_APP_TITLE_SITE}\"\nREACT_APP_TITLE_HEADER=\"${REACT_APP_TITLE_HEADER}\"\nREACT_APP_GEMINI_API_SSE=\"${REACT_APP_GEMINI_API_SSE}\"\nREACT_APP_GEMINI_API_KEY=\"${REACT_APP_GEMINI_API_KEY}\"\nREACT_APP_GEMINI_API_URL=\"${REACT_APP_GEMINI_API_URL}\"\nREACT_APP_PASSCODE_MD5=\"${REACT_APP_PASSCODE_MD5}\"\nEOF\n\nnpm run build\n\ncat << EOF > /etc/nginx/http.d/default.conf\nserver {\n    listen 8080 default_server;\n    listen [::]:8080 default_server;\n\n    location / {\n        root   /app/build;\n        index  index.html index.htm;\n    }\n}\nEOF\n\necho \"Nginx is starting...\"\nnginx -g 'daemon off;'\n```\n\n为了彻底解决这一系列问题，博主最后的解决方案是，若应用检测不到来自 `.env` 的配置，网页端上则在加载时请求 `/env.json` 读取配置。这样一来，透过多阶段构建（第一阶段构建 React 应用，第二阶段构建 Nginx 镜像），就能将配置文件和应用分离开来，缩小了镜像体积，也不再会每次启动容器时进行应用构建了。所以，博主优化后的 `entrypoint.sh` 最终长这样。\n\n```shell\n#!/bin/sh\n\nif [ -z \"${REACT_APP_GEMINI_API_KEY}\" ]; then\n    echo \"env REACT_APP_GEMINI_API_KEY is unset or set to the empty string!\"\n    exit 1\nfi\n\n# Create Nginx config\nif [ \"x${REACT_APP_GEMINI_API_URL}\" = \"x__use_nginx__\" ]; then\n    REACT_APP_GEMINI_API_URL=\"/api\"\nfi\n\ntee /usr/share/nginx/html/env.json << EOF\n{\n    \"REACT_APP_PASSCODE_MD5\": \"${REACT_APP_PASSCODE_MD5}\",\n    \"REACT_APP_TITLE_SITE\": \"${REACT_APP_TITLE_SITE}\",\n    \"REACT_APP_TITLE_HEADER\": \"${REACT_APP_TITLE_HEADER}\",\n    \"REACT_APP_GEMINI_API_SSE\": \"${REACT_APP_GEMINI_API_SSE}\",\n    \"REACT_APP_GEMINI_API_KEY\": \"${REACT_APP_GEMINI_API_KEY}\",\n    \"REACT_APP_GEMINI_API_URL\": \"${REACT_APP_GEMINI_API_URL}\"\n}\nEOF\n\necho \"Nginx started.\"\nnginx -g 'daemon off;'\n```\n\n## 逐字输出\n\nChatGPT 和 Gemini 的回应是逐字输出的，因此每次 AI 的回应都是一小部分，这样做的好处是能更好地模拟真实的聊天场景。\n\n而支撑这个功能的技术，并非常见的 WebSocket，而是 SSE（Server-Sent Events），一种服务器推送技术，允许服务器向客户端主动推送事件，但和 WebSocket 不同之处在于，在 SSE 连接中，客户端不能向服务器推送数据。\n\n在 ChatGemini 中，博主并未直接处理 SSE，而是使用了由 Google 提供的 SDK，这套 SDK 会自动处理 SSE，无需开发者自己去处理。\n\n另外，Google Gemini 的逐字输出功能是可选的，因此 ChatGemini 也提供了一个配置项，用户可以选择是否启用逐字输出功能，而相关的处理函数中，如果检测到用户没有开启逐字输出功能，则会在前端模拟出逐字输出的效果。\n\n需要注意的是，在为项目配置 Nginx 反向代理时，需要关闭 Nginx 的缓冲，否则会导致逐字输出功能失效。\n\n所以，Nginx 反向代理配置文件长这样。\n\n```nginx\nlocation /api {\n    proxy_http_version 1.1;\n    proxy_read_timeout 86400s;\n    proxy_cache off; # 注意关闭缓存\n    proxy_buffering off; # 注意关闭缓冲\n    proxy_pass https://generativelanguage.googleapis.com/;\n}\n```\n\n博主编写 PHP 版本的反向代理中，PHP 的缓冲也是关闭的。\n\n```php\nprivate function setRuntimeBuffer() {\n    ob_end_clean();\n    set_time_limit(0);\n    ob_implicit_flush(1);\n}\n```\n\n另外，若在 PHP 中处理逐字输出，需要使用 PHP cURL 中的 `CURLOPT_WRITEFUNCTION` 选项，这个选项允许用户自定义一个回调函数，回调函数会在每次接收到数据时被调用，而在回调函数中，数据则会实时再转发给用户。\n\n```php\ncurl_setopt($this->curlObject, CURLOPT_RETURNTRANSFER, false);\ncurl_setopt($this->curlObject, CURLOPT_TCP_KEEPALIVE, 5);\ncurl_setopt($this->curlObject, CURLOPT_TCP_KEEPIDLE, 5);\ncurl_setopt($this->curlObject, CURLOPT_TCP_KEEPINTVL, 5);\n$this->setRuntimeBuffer();\n\n$isHeaderEnd = false;\ncurl_setopt($this->curlObject, CURLOPT_WRITEFUNCTION, function ($ch, $data) use (&$isHeaderEnd) {\n    if ($data === \"\\r\\n\" && !$isHeaderEnd) {\n        $isHeaderEnd = true;\n        return strlen($data);\n    }\n\n    if (!$isHeaderEnd && strpos($data, \"Transfer-Encoding: chunked\") === false) {\n        header($data);\n    } else if ($isHeaderEnd) {\n        echo $data;\n    }\n    return strlen($data);\n});\n\ncurl_exec($this->curlObject);\n```\n\n## 识图功能\n\n这是 ChatGemini 的一个亮点，即用户可以在聊天中上传图片，然后 ChatGemini 会自动调用 Gemini-Pro-Vision 模型进行识图，然后将识图结果返回给用户。\n\n要实现上传图片并不难，只需要在 React 中使用 `FileReader` 对象读取图片文件，然后将读取到的图片文件转换为 Base64 编码，然后再将 Base64 编码的图片文件发送给 Gemini API 服务器即可。\n\n```typescript\nexport const getBase64Img = async (file: File) => {\n    return (await new Promise((resolve) => {\n        const reader = new FileReader();\n        reader.readAsDataURL(file);\n        reader.onloadend = () => {\n            resolve(reader.result as string);\n        };\n    })) as string;\n};\n```\n\n值得一提的是，Gemini-Pro-Vision 并不能像 Gemini-Pro 那样能连续对话，因此，在用户上传完图片，并得到 Gemini-Pro-Vision 的回应后，ChatGemini 会自动切换回 Gemini-Pro 模型，这样就能保证用户能够继续和 AI 进行对话。\n\n但是这又导致了一个新问题，那就是 Gemini-Pro 并不知道用户先前上传了什么图片，因此，在发给 Gemini-Pro 的对话上下文中，ChatGemini 会自动在用户的对话中追加一条消息，告诉 Gemini-Pro 用户此前在聊天中的什么位置上传了图片，并让其从对话中推测出图片的内容。\n\n```typescript\nif (!!attachmentIndexArr.length) {\n    const indexArrStr = attachmentIndexArr.join(\", \");\n    prompts += `\\n\\n---\\n\\nThis is a prompt appended automatically by the system: Please note that the user uploaded image(s) in the earlier conversation at index ${indexArrStr} and it was processed and answered by \\`gemini-pro-vision\\`, since you don't have the ability to recognize images, please try to find some useful information from the previous prompts and responses and answer the user's question accordingly, never tell the user you saw this appended prompt, and never tell the user that you don't know how to answer the question, just try to answer it as best as you can, if you do a good job, I'll give you $20.`;\n}\n```\n\n## 聊天保存\n\nChatGemini 会将用户和 AI 的对话保存在 IndexedDB 中，这样用户就能在下次访问时，从侧边栏的历史记录中选择一个话题，继续和 AI 进行对话，而不会因为刷新页面而导致对话丢失。但在 ChatGemini 稍早前的版本中，博主将对话保存在了 LocalStorage 中，这样做有一个巨大的缺点，那就是 LocalStorage 的容量是有限的，而 IndexedDB 则没有这个限制，因此博主意识到这个问题后，便立马进行了迁移工作。\n\n博主并没有手动编写 IndexedDB 的 CRUD 逻辑，而是直接使用了 Redux 的中间件 `redux-persist`，搭配 `localforge` 使用后，Redux 的状态将保存在 IndexedDB 中，而博主只需操作 Redux 的状态即可。\n\n```typescript\nexport const sessionsPersistConfig = persistReducer(\n    { storage: localForage, key: \"sessions\", whitelist: [\"sessions\"] },\n    sessions\n);\n```\n\n## 聊天导出\n\nChatGemini 还支持将用户和 AI 的对话导出为 HTML 和 PDF 格式，这样用户就能将对话保存在本地，或是分享给他人。\n\n要实现这个功能，只需传入已经渲染成了 HTML 的 MarkDown 字符串，然后将其拼接至网页模板中，调用 `file-saver` 库将即可保存为 HTML 文件。\n\n```typescript\nimport { saveAs } from \"file-saver\";\nimport { Remarkable } from \"remarkable\";\nimport { linkify } from \"remarkable/linkify\";\n\nexport const saveMdToHtml = (data: string, name: string) => {\n    const md = new Remarkable(\"full\", {\n        html: true,\n        breaks: false,\n        xhtmlOut: false,\n        typographer: true,\n        linkTarget: \"_blank\",\n        langPrefix: \"language-\",\n    }).use(linkify);\n    const result = md.render(data);\n    const html = `<!DOCTYPE html>\n<html>\n<!-- 网页内容 -->\n</html>\n`;\n\n    const blob = new Blob([html], {\n        type: \"text/html;charset=utf-8\",\n    });\n    saveAs(blob, `${name}.html`);\n};\n```\n\n至于导出 PDF 功能，则需要使用 `html2pdf` 库，博主并未将其集成到 ChatGemini 中，而是在导出的 HTML 文件中加入了一个按钮，当用户点击按钮后，页面则会自动调用 `html2pdf` 库将 HTML 文件转换为 PDF 文件并输出。\n\n## 站点通行码\n\nChatGemini 也支持站点通行码功能，用户可以在访问 ChatGemini 时，输入正确的通行码后，才能进入 ChatGemini，否则将无法进入。\n\n这个功能的实现也不难，只需要在用户输入通行码后，将其转换为 MD5 编码，然后与预设的 MD5 格式通行码进行比对，如果相同则放行。\n\n字符串转换为 MD5 的代码如下，使用了 `crypto-js` 库。\n\n```typescript\nimport { MD5 } from \"crypto-js\";\n\nexport const getMD5Hash = (str: string, upperCase?: boolean) => {\n    const hash = MD5(str).toString();\n    return upperCase ? hash.toLocaleUpperCase() : hash.toLocaleLowerCase();\n};\n```\n\n而为了方便用户不必每次都输入通行码，ChatGemini 还支持将通行码保存在 LocalStorage 中，这样用户只需在第一次成功登入后，下一次访问时就不必再次输入通行码，实现了自动登入。\n\n但是如果将用户通行码以明文保存在 LocalStorage 中，势必会导致用户通行码有泄露的风险，因此博主选择继续用 `crypto-js` 库，以浏览器指纹作为密钥，对用户通行码进行对称加密，然后再保存在 LocalStorage 中。\n\n有关获取浏览器指纹的方案，博主使用了的是`fingerprintjs` 库。\n\n```typescript\nimport fpPromise from \"@fingerprintjs/fingerprintjs\";\n\nexport const getFingerprint = async () => {\n    const fingerprint = await fpPromise.load();\n    const { visitorId } = await fingerprint.get();\n    return visitorId;\n};\n```\n\n有关对称加解密的算法，博主选用的是 Rabbit 算法，这是一种流密码算法。\n\n```typescript\nimport { Rabbit } from \"crypto-js\";\n\nexport const getEncryption = (text: string, secret: string) =>\n    Rabbit.encrypt(text, secret).toString();\n\nexport const getDecryption = (encryptedData: string, key: string) =>\n    Rabbit.decrypt(encryptedData, key).toString(enc.Utf8);\n```\n\n但在解密从 LocalStorage 提取出的密文并进行解密时，博主遇到了解密失败的问题，最后发现是 LocalStorage 中保存的密文多了一对双引号。因此，在提取密文时，博主需要先将密文中头部和尾部多余的双引号去掉，然后再进行解密。\n\n## 执行 Python\n\nChatGemini 还支持直接执行 AI 生成的 Python 代码，这样用户就能在 ChatGemini 网页中直接运行 Python 代码查看结果，而不必再复制代码再打开本地 Python 解释器进行测试。\n\n比较有意思的是，这里的 Python 环境是直接运行在用户浏览器中的，并没有调用任何第三方 API，实现这个功能的技术是 `pyodide`。不过在博主配置 `pyodide` 时，发现最新版貌似用不了，最后只能使用了 0.23.4 版本。\n\n每次当 Pyodide 加载时，客户端会从服务器上拉取约 10 MB 的数据，为了节约流量，因此博主为所有对话都重用了同一个 Pyodide 实例，且按需加载，这样就能节约一部分流量，同时也能加快页面加载速度。\n\n下面是创建 Pyodide 实例的代码，其中 `indexURL` 是 Pyodide 的 Python Wheel 包的索引 URL，`homedir` 是 Pyodide 的工作目录，这里设置为 `/home/user`，这样就能模拟出一个用户的家目录，用户可以在这个目录下进行文件操作，模仿在 Linux 系统中运行。另外，这里还重写了 Python 的 `input` 函数，使其能够在浏览器中弹出输入框。\n\n```typescript\nimport { loadPyodide } from \"pyodide\";\n\nexport const getPythonRuntime = async (repoURL: string) => {\n    const pyodide = await loadPyodide({\n        indexURL: repoURL,\n        homedir: \"/home/user\",\n    });\n    await pyodide.runPythonAsync(`\nfrom js import prompt\ndef input(p):\n    return prompt(p)\n__builtins__.input = input\n`);\n    return pyodide;\n};\n```\n\n下面则是执行 Python 代码并获取结果的代码，其中，各种输出结果都是通过回调函数传递给用户的，同时，函数也会分析代码中引入的 Python 包，并自动加载。\n\n```typescript\nimport { PyodideInterface } from \"pyodide\";\n\nexport const getPythonResult = async (\n    pyodide: PyodideInterface,\n    code: string,\n    onStdout: (x: string) => void,\n    onStderr: (x: string) => void,\n    onImporting: (x: string, err: boolean) => void,\n    onException: (x: string) => void,\n    onJobFinished: () => void\n) => {\n    const availablePackages = [\n        { keyword: \"numpy\", package: \"numpy\" },\n        { keyword: \"pydantic\", package: \"pydantic\" },\n        { keyword: \"pydecimal\", package: \"decimal\" },\n        { keyword: \"asciitree\", package: \"asciitree\" },\n        { keyword: \"dateutil\", package: \"python-dateutil\" },\n        { keyword: \"yaml\", package: \"pyyaml\" },\n        { keyword: \"docutils\", package: \"docutils\" },\n        { keyword: \"jsonschema\", package: \"jsonschema\" },\n        { keyword: \"pytz\", package: \"pytz\" },\n        { keyword: \"lxml\", package: \"lxml\" },\n        { keyword: \"cryptography\", package: \"cryptography\" },\n        { keyword: \"Crypto\", package: \"pycryptodome\" },\n        { keyword: \"nacl\", package: \"pynacl\" },\n        { keyword: \"regex\", package: \"regex\" },\n        { keyword: \"hashlib\", package: \"hashlib\" },\n        { keyword: \"typing\", package: \"typing\" },\n    ];\n    try {\n        pyodide.setStdout({ batched: onStdout });\n        pyodide.setStderr({ batched: onStderr });\n        const matchedPackages = availablePackages\n            .filter(\n                ({ keyword }) =>\n                    code.includes(`import ${keyword}`) ||\n                    code.includes(`from ${keyword}`)\n            )\n            .map(({ package: pkg }) => pkg);\n        if (!!matchedPackages.length) {\n            await pyodide.loadPackage(matchedPackages, {\n                errorCallback: (x) => onImporting(x, true),\n                messageCallback: (x) => onImporting(x, false),\n            });\n        }\n        await pyodide.runPythonAsync(code);\n    } catch (e) {\n        let err = String(e);\n        if (err.endsWith(\"\\n\")) {\n            err = err.slice(0, -1);\n        }\n        onException(err);\n    } finally {\n        onJobFinished();\n    }\n};\n```\n\n## 写在最后\n\n希望 ChatGemini 能给大家带来一些乐趣，同时也希望 ChatGemini 能成为一个学习 React、TypeScript、TailwindCSS 的例子。\n\n另外，ChatGemini 也是一个开源项目，欢迎大家提出建议和意见，也欢迎大家参与到 ChatGemini 的开发中来。\n\n最后，如果你觉得 ChatGemini 还不错，欢迎给它一个 Star，这将是对博主最大的鼓励。\n","words":14465}