{"title":"Orange Pi 使用 mmap 控制 GPIO","created_at":1684559280000,"updated_at":1693292468498,"content":"\n博主曾经接手的一个项目，主控板连续好几年使用的一直是 Rapsberry Pi，但是随着 Raspberry Pi 价格长期居高不下，让人直呼伤不起，只能考虑把板子换成更便宜的方案，再三权衡之下，博主最后选了 Orange Pi One。\n\nOrange Pi One 使用了 Allwinner H3 作为 CPU，内建 512 MB 运存，对于博主的项目来说绰绰有余，另外，Orange Pi One 的 GPIO 定义和 Raspberry Pi 相同，而且闲鱼上的售价普遍 70 左右，和树莓派现在的售价比起来，直接少了个 0，让人很难不心动。\n\n悲催的是，这个项目恰好就用到了 Raspberry Pi 的 GPIO，而且原本的代码中并没有用外部库去操作 GPIO，只是使用了**内存映射**的方式，透过读写内存来操作 GPIO。\n\n我们知道，不同的 CPU 之间，内部的寄存器集合与地址也都会有所不同，所以在博主想碰碰运气，尝试过直接换板子，发现果然运行不了之后，博主只能很不情愿地改代码去了。\n\n这篇文章将会介绍博主如何理解 mmap 的概念，如何看懂 Allwinner H3 提供的 Datasheet，以及如何成功编写程序控制 GPIO 的一整套流程，希望能对您有所帮助。\n\n![博主的 Orange Pi One](https://c.ibcl.us/OrangePi-MMAP_20230520/1.jpg)\n\n\n\n# 为什么要用 mmap\n\n简单来说，mmap 可以透过将一片物理内存空间映射到应用的虚拟内存空间，这样一来，我们就能直接在应用层就能操作 CPU 的寄存器。\n\n在常规的开发中，我们通常会用 Linux 通用的 sysfs 方式去控制 GPIO，使 GPIO 输出指定的电平，或是从 GPIO 读取外部向 GPIO 输入的电平。\n\n但是，这种方法只适合于一般对速度要求不高的场合，在需要高速访问 GPIO 的场合，这种方式还是比较吃力的。这是因为 sysfs 是透过文件 IO 操作进行 GPIO 控制，每次操作都需要进行文件系统的访问和系统调用，这都会引入一定的性能开销。\n\n所以，若要破除额外的性能开销，突破文件 IO 瓶颈，那就需要想办法绕过它们，而 mmap 这种方法可以直接在物理内存中进行 GPIO 相关操作，按理说可以实现更快速的 GPIO 访问速度。\n\n# mmap 控制 GPIO 的原理\n\n我们知道，开发板上的 GPIO 实际上就是 CPU 上的一部分引脚，由于这一部分引脚可以透过程序控制，那么 CPU 内必然有与之对应的寄存器，那么也就必然有与之对应的物理地址区段，同时这个区段是不会改变的。而我们可以透过 mmap 操作 CPU 内部寄存器，那么就可以透过这种方式控制指定的 GPIO。\n\n要透过 mmap 控制 GPIO，流程有如下 5 步。\n\n 1. 打开 `/dev/mem` 装置文件\n 2. 确定 GPIO 控制寄存器的物理地址\n 3. 使用 mmap 映射物理地址到用户空间\n 4. 访问 GPIO 控制寄存器\n 5. 取消 mmap 映射\n\n在这 5 步中，第 2 步需要查阅 CPU 厂商所提供的 Datasheet 来确定。\n\n# 查阅 Allwinner H3 Datasheet\n\n透过 Google，博主找到了 [Allwinner H3 的 Datasheet](https://dl.linux-sunxi.org/H3/Allwinner_H3_Datasheet_V1.0.pdf)。由于 Datasheet 有惊人的 618 页，不可能每页都看完，我们只需要按下 Ctrl + F 搭配搜索如下关键词即可。\n\n - Base Address：基础地址\n - Register：寄存器\n\n在第 90 页 4.3.4. Register List 位置，我们得知，**CPU 内所有寄存器基础地址为 0x01C20000**；继续搜索后，在 318 页 4.22.1. Port Controller Register List 位置，可以了解到 Allwinner H3 的 **GPIO 寄存器基础地址为 0x01C20800**。由此，我们可以得出结论，**GPIO 寄存器基础地址**相对于 **CPU 内所有寄存器基础地址**的偏移量为 0x0800。\n\n接下来，我们需要知道 GPIO 寄存器的具体配置。在 318 页 4.22.2. Port Controller Register 位置，我们可以看到寄存器表格，去除中断引脚，对于我们有用的寄存器配置如下。\n\n| 寄存器名称 | 寄存器偏移    | 寄存器描述                                              | 博主注                                                           |\n| :--------- | :------------ | :------------------------------------------------------ | :--------------------------------------------------------------- |\n| Pn_CFG0    | n*0x24 + 0x00 | GPIO n 配置寄存器 0，用于配置 GPIO n 的模式             | 先确定好要设定 GPIO 模式的端口号（如 GPIO_A）以及管脚号（如 A6） |\n| Pn_CFG1    | n*0x24 + 0x04 | GPIO n 配置寄存器 1，用于配置 GPIO n 的模式             | 然后在 Datasheet 中此表格后续的 Pn Configure Register x 表中     |\n| Pn_CFG2    | n*0x24 + 0x08 | GPIO n 配置寄存器 2，用于配置 GPIO n 的模式             | n = [0...6]，x = [1...3] 找到确切管脚对应之「位」与模式之「值」  |\n| Pn_CFG3    | n*0x24 + 0x0C | GPIO n 配置寄存器 3，用于配置 GPIO n 的模式             | （上文提及之代号 n 亦指代 GPIO 端口号 A、C、D、E、F、G、L 之一） |\n| Pn_DAT     | n*0x24 + 0x10 | GPIO n 数据寄存器，用于存取 GPIO n 的状态               | 输入模式时对应位表示引脚状态；输出模式时引脚状态与对应位相同     |\n| Pn_DRV0    | n*0x24 + 0x14 | GPIO n 驱动能力寄存器 0，用于配置 GPIO n 的驱动能力     |                                                                  |\n| Pn_DRV1    | n*0x24 + 0x18 | GPIO n 驱动能力寄存器 1，用于配置 GPIO n 的驱动能力     |                                                                  |\n| Pn_PUL0    | n*0x24 + 0x1C | GPIO n 上拉电阻控制寄存器 0，用于配置 GPIO n 的上拉电阻 |                                                                  |\n| Pn_PUL1    | n*0x24 + 0x20 | GPIO n 上拉电阻控制寄存器 1，用于配置 GPIO n 的上拉电阻 |                                                                  |\n\n此外，虽然我们知道了 GPIO 的寄存器基础地址为 0x01C20800，但是我们要控制的 GPIO 是 GPIO_A，所以我们还需要知道 GPIO_A 相对于 GPIO 寄存器基础地址的偏移量。\n\n继续翻阅 Datasheet，我们可以在 319 页 4.22.2.1. PA Configure Register 0 位置了解到，GPIO_A 端口寄存器相对于 GPIO 寄存器基础地址的偏移量为 0x00，同时 GPIO_A 端口寄存器的所有配置结束于 0x01C20820，位宽 0x20 字节。\n\n综上所述，我们可以用一个结构体类型 `gpio_t` 来描述上述寄存器。\n\n```C\ntypedef struct {\n    volatile uint32_t config[4];\n    volatile uint32_t data;\n    volatile uint32_t driver[2];\n    volatile uint32_t pull[2];\n} gpio_t;\n```\n\n在这个结构体中，`volatile` 关键字用于告诉编译器，这个结构体中的成员变量可能会被其他线程或者中断修改，所以编译器不要对这个结构体进行优化。\n\n了解了 GPIO 寄存器的配置，我们可以透过一个实例来说明如何配置 GPIO。\n\n例如，我们要控制 GPIO_A20 为输出模式，并输出高电平，透过查询 Datasheet，我们需要得知以下几条与 GPIO_A20 相关的资讯。\n\n 1. GPIO_A20 的配置位于 PA_CFG2_REG 寄存器中第 20-22 位，其值为 0x01 时为输出模式\n 2. 当 PA_DATA_REG 寄存器第 20 位值为 0x01 时，即可输出高电平\n\n又例如，我们要控制 GPIO_A8 为输入模式，并使能上拉电阻，透过查询 Datasheet，我们需要得知以下几条与 GPIO_A8 相关的资讯。\n\n 1. GPIO_A8 的配置位于 PA_CFG1_REG 寄存器中第 0-2 位，其值为 0x00 时为输入模式\n 2. 当 PA_PULL0_REG 寄存器第 16-17 位值为 0x01 时，即可使能上拉电阻\n\n# 编程解决问题\n\n有了以上知识做铺垫，我们就可以开始编写程序解决问题了。\n\n博主将以 C 语言、Go 语言与 Python 为例，透过 mmap 操作 GPIO，实现 GPIO_A21 管脚带动 LED 灯闪烁，同时读取 GPIO_A8 管脚电平并打印到终端。\n\n**由于 GPIO_A8 管脚设定了上拉使能，所以除非用户将这个管脚接地，否则读出的电平始终为高**；同理，若用户设定了下拉使能，则除非用户将这个管脚接到 Vcc，否则读出的电平始终为低。\n\n## C 语言版本\n\n以下是 C 语言的版本，其中，`gpio_t` 结构体的定义与上文相同，`set_output` 函数用于将 GPIO 端口设置为输出模式，`set_input` 函数用于将 GPIO 端口设置为输入模式，`set_level` 函数用于设定 GPIO 端口电平，`get_level` 函数用于读取 GPIO 端口的电平。\n\n```cpp\n#include <fcntl.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <sys/mman.h>\n#include <unistd.h>\n\n// GPIO_A 配置寄存器列表\n// { 寄存器号, 寄存器位 }\nconst int GPIO_A_CONFIG[22][2] = {\n    {0, 0},   // PA0\n    {0, 4},   // PA1\n    {0, 8},   // PA2\n    {0, 12},  // PA3\n    {0, 16},  // PA4\n    {0, 20},  // PA5\n    {0, 24},  // PA6\n    {0, 28},  // PA7\n\n    {1, 0},   // PA8\n    {1, 4},   // PA9\n    {1, 8},   // PA10\n    {1, 12},  // PA11\n    {1, 16},  // PA12\n    {1, 20},  // PA13\n    {1, 24},  // PA14\n    {1, 28},  // PA15\n\n    {2, 0},   // PA16\n    {2, 4},   // PA17\n    {2, 8},   // PA18\n    {2, 12},  // PA19\n    {2, 16},  // PA20\n    {2, 20},  // PA21\n};\n\n// 寄存器基础地址\n#define ALLWINNER_H3_BASE 0x01C20000\n// GPIO_A 相对于 ALLWINNER_H3_BASE 偏移量\n#define GPIO_PA_OFFSET 0x0800\n// 指定在使用 mmap 函数时要映射的区域大小\n#define MMAP_SIZE 0x1000\n\n// GPIO 模式设定\nenum GPIO_MODE {\n    INPUT = 0,\n    OUTPUT,\n};\n// GPIO 电平设定\nenum GPIO_LEVEL {\n    LOW = 0,\n    HIGH,\n};\n// GPIO 上拉下拉设定\nenum GPIO_PULL {\n    PULL_OFF = 0,\n    PULL_UP,\n    PULL_DOWN,\n};\n\n// GPIO 端口寄存器类型\ntypedef struct {\n    volatile uint32_t config[4];\n    volatile uint32_t data;\n    volatile uint32_t driver[2];\n    volatile uint32_t pull[2];\n} gpio_t;\n\n// 配置 GPIO_A 的指定管脚为输出模式\nvoid set_output(gpio_t* gpio, int pin) {\n    // 取得寄存器号与寄存器位\n    int reg = GPIO_A_CONFIG[pin][0];\n    int bit = GPIO_A_CONFIG[pin][1];\n    // 清空原有配置\n    gpio->config[reg] &= ~(0x0F << bit);\n    // 设为输出模式\n    gpio->config[reg] |= (OUTPUT << bit);\n}\n\n// 配置 GPIO_A 的指定管脚为输入模式\nvoid set_input(gpio_t* gpio, int pin) {\n    // 取得寄存器号与寄存器位\n    int reg = GPIO_A_CONFIG[pin][0];\n    int bit = GPIO_A_CONFIG[pin][1];\n    // 清空原有配置\n    gpio->config[reg] &= ~(0x0F << bit);\n    // 设为输入模式\n    gpio->config[reg] |= (INPUT << bit);\n}\n\n// 设定 GPIO_A 的指定管脚上拉下拉\nvoid set_pull(gpio_t* gpio, int pin, int pull) {\n    // 取得寄存器号\n    int reg = pin / 16;\n    // 取得寄存器位\n    int bit = (pin % 16) * 2;\n    // 清空原有配置\n    gpio->pull[reg] &= ~(0x03 << bit);\n    // 设定上拉下拉\n    gpio->pull[reg] |= (uint32_t)pull << bit;\n}\n\n// 设定 GPIO_A 的指定管脚电平\nvoid set_level(gpio_t* gpio, int pin, int level) {\n    switch (level) {\n        case HIGH:\n            gpio->data |= (1 << pin);\n            return;\n        case LOW:\n            gpio->data &= ~(1 << pin);\n            return;\n        defaults:\n            return;\n    }\n}\n\n// 读取 GPIO_A 的指定管脚电平\nint get_level(gpio_t* gpio, int pin) {\n    // 取得寄存器号与寄存器位\n    int reg = GPIO_A_CONFIG[pin][0];\n    int bit = GPIO_A_CONFIG[pin][1];\n    // 清空原有配置\n    gpio->config[reg] &= ~(0x0F << bit);\n    return (gpio->data >> pin) & 0x01;\n}\n\nint main() {\n    // 以读写模式打开 /dev/mem 装置文件\n    int mem = open(\"/dev/mem\", O_RDWR | O_SYNC);\n    if (mem < 0) {\n        perror(\"open /dev/mem\");\n        return -1;\n    }\n\n    // 将寄存器映射到内存\n    char* reg = (char*)mmap(NULL, MMAP_SIZE, PROT_READ | PROT_WRITE, MAP_SHARED,\n                            mem, ALLWINNER_H3_BASE);\n    if (reg == MAP_FAILED) {\n        perror(\"mmap\");\n        close(mem);\n        return -1;\n    }\n\n    // 将映射的地址偏移量应用于 GPIO_A 寄存器类型\n    gpio_t* gpio = (gpio_t*)&reg[GPIO_PA_OFFSET];\n\n    // 设定 GPIO_A21 为输出模式\n    set_output(gpio, 21);\n    // 设定 GPIO_A8 为输入模式\n    set_input(gpio, 8);\n    // 设定 GPIO_A8 上拉使能\n    set_pull(gpio, 8, PULL_UP);\n\n    // 闪烁 LED 灯并读取电平\n    for (;;) {\n        // 闪烁 GPIO_A21 LED\n        set_level(gpio, 21, HIGH);\n        usleep(500000);\n        set_level(gpio, 21, LOW);\n        usleep(500000);\n        // 读取 GPIO_A8 电平并打印\n        int level = get_level(gpio, 8);\n        printf(\"GPIO_A8 level: %d\\n\", level);\n    }\n\n    // 解除内存映射\n    munmap(gpio, MMAP_SIZE);\n    close(mem);\n\n    return 0;\n}\n```\n\n## Go 语言版本\n\n作为一个 Gopher，当然也要用 Go 语言来实现一遍了。\n\n在 Go 语言的版本中，内存映射使用了 `syscall.Mmap()` 和 `syscall.Munmap()` 函数。\n\n此外，在之前的 C 代码中，使用了强制类型转换 `(gpio_t *)` 和解引用运算符 `*` 来进行指针转换，而在 Go 版本的实现中，指针转换是使用 `unsafe.Pointer` 类型与 `unsafe.Pointer()` 函数来进行指针转换，从而实现了直接操作内存地址。\n\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"os\"\n\t\"syscall\"\n\t\"time\"\n\t\"unsafe\"\n)\n\n// GPIO_A 配置寄存器列表\n// { 寄存器号, 寄存器位 }\nvar GPIO_A_CONFIG = [22][2]int{\n\t{0, 0},  // PA0\n\t{0, 4},  // PA1\n\t{0, 8},  // PA2\n\t{0, 12}, // PA3\n\t{0, 16}, // PA4\n\t{0, 20}, // PA5\n\t{0, 24}, // PA6\n\t{0, 28}, // PA7\n\n\t{1, 0},  // PA8\n\t{1, 4},  // PA9\n\t{1, 8},  // PA10\n\t{1, 12}, // PA11\n\t{1, 16}, // PA12\n\t{1, 20}, // PA13\n\t{1, 24}, // PA14\n\t{1, 28}, // PA15\n\n\t{2, 0},  // PA16\n\t{2, 4},  // PA17\n\t{2, 8},  // PA18\n\t{2, 12}, // PA19\n\t{2, 16}, // PA20\n\t{2, 20}, // PA21\n}\n\nconst (\n\t// 寄存器基础地址\n\tALLWINNER_H3_BASE = 0x01C20000\n\t// GPIO_A 相对于 ALLWINNER_H3_BASE 偏移量\n\tGPIO_PA_OFFSET = 0x0800\n\t// 指定在使用 mmap 函数时要映射的区域大小\n\tMMAP_SIZE = 0x1000\n)\n\n// GPIO 模式设定\nconst (\n\tINPUT  = 0\n\tOUTPUT = 1\n)\n\n// GPIO 电平设定\nconst (\n\tLOW  = 0\n\tHIGH = 1\n)\n\n// 上拉下拉设定\nconst (\n\tPULL_OFF  = 0\n\tPULL_UP   = 1\n\tPULL_DOWN = 2\n)\n\n// GPIO 端口寄存器类型\ntype gpio_t struct {\n\tconfig [4]uint32\n\tdata   uint32\n\tdriver [2]uint32\n\tpull   [2]uint32\n}\n\nfunc setOutput(gpio *gpio_t, pin int) {\n\t// 取得寄存器号与寄存器位\n\treg := GPIO_A_CONFIG[pin][0]\n\tbit := GPIO_A_CONFIG[pin][1]\n\t// 清空原有配置\n\tgpio.config[reg] &= ^(0x0F << bit)\n\t// 设为输出模式\n\tgpio.config[reg] |= OUTPUT << bit\n}\n\nfunc setInput(gpio *gpio_t, pin int) {\n\t// 取得寄存器号与寄存器位\n\treg := GPIO_A_CONFIG[pin][0]\n\tbit := GPIO_A_CONFIG[pin][1]\n\t// 清空原有配置\n\tgpio.config[reg] &= ^(0x0F << bit)\n\t// 设为输入模式\n\tgpio.config[reg] |= INPUT << bit\n}\n\nfunc setPull(gpio *gpio_t, pin, pull int) {\n\t// 取得寄存器号\n\treg := pin / 16\n    // 取得寄存器位\n    bit := (pin % 16) * 2;\n\t// 清空原有配置\n\tgpio.pull[reg] &= ^(0x03 << bit)\n\t// 设定上拉下拉\n\tgpio.pull[reg] |= uint32(pull) << bit\n}\n\nfunc setLevel(gpio *gpio_t, pin, level int) {\n\tswitch level {\n\tcase HIGH:\n\t\tgpio.data |= 1 << pin\n\tcase LOW:\n\t\tgpio.data &= ^(1 << pin)\n\t}\n}\n\nfunc getLevel(gpio *gpio_t, pin int) int {\n\t// 取得寄存器号与寄存器位\n\treg := GPIO_A_CONFIG[pin][0]\n\tbit := GPIO_A_CONFIG[pin][1]\n\t// 清空原有配置\n\tgpio.config[reg] &= ^(0x0F << bit)\n\treturn int((gpio.data >> pin) & 0x01)\n}\n\nfunc main() {\n\t// 以读写模式打开 /dev/mem 装置文件\n\tmem, err := os.OpenFile(\"/dev/mem\", os.O_RDWR|os.O_SYNC, 0)\n\tif err != nil {\n\t\tfmt.Printf(\"Failed to open /dev/mem: %v\\n\", err)\n\t\treturn\n\t}\n\tdefer mem.Close()\n\n\t// 将寄存器映射到内存\n\treg, err := syscall.Mmap(int(mem.Fd()), ALLWINNER_H3_BASE, MMAP_SIZE, syscall.PROT_READ|syscall.PROT_WRITE, syscall.MAP_SHARED)\n\tif err != nil {\n\t\tfmt.Printf(\"Failed to mmap: %v\\n\", err)\n\t\treturn\n\t}\n\tdefer syscall.Munmap(reg)\n\n\t// 将映射的地址偏移量应用于 GPIO_A 寄存器类型\n\tgpio := (*gpio_t)(unsafe.Pointer(&reg[GPIO_PA_OFFSET]))\n\n\t// 设定 GPIO_A21 为输出模式\n\tsetOutput(gpio, 21)\n\t// 设定 GPIO_A8 为输入模式\n\tsetInput(gpio, 8)\n\t// 设定 GPIO_A8 上拉使能\n\tsetPull(gpio, 8, PULL_UP)\n\n\t// 闪烁 LED 灯并读取电平\n\tfor {\n\t\t// 闪烁 GPIO_A21 LED\n\t\tsetLevel(gpio, 21, HIGH)\n\t\ttime.Sleep(time.Millisecond * 500)\n\t\tsetLevel(gpio, 21, LOW)\n\t\ttime.Sleep(time.Millisecond * 500)\n\t\t// 读取 GPIO_A8 电平并打印\n\t\tlevel := getLevel(gpio, 8)\n\t\tfmt.Printf(\"GPIO_A8 level: %d\\n\", level)\n\t}\n}\n```\n\n## Python 版本\n\nPython 版本的实现与 Go 版本的实现类似，不过在 Python 中，内存映射使用了 `mmap` 模块。\n\n```python\nfrom mmap import mmap, MAP_SHARED, PROT_READ, PROT_WRITE\nfrom os import open, close, O_RDWR, O_SYNC\nfrom ctypes import Structure, c_uint32\nfrom typing import Type\nfrom time import sleep\nfrom sys import exit\n\n# GPIO_A 配置寄存器列表\n# { 寄存器号, 寄存器位 }\nGPIO_A_CONFIG = [\n    [0, 0],  # PA0\n    [0, 4],  # PA1\n    [0, 8],  # PA2\n    [0, 12],  # PA3\n    [0, 16],  # PA4\n    [0, 20],  # PA5\n    [0, 24],  # PA6\n    [0, 28],  # PA7\n    [1, 0],  # PA8\n    [1, 4],  # PA9\n    [1, 8],  # PA10\n    [1, 12],  # PA11\n    [1, 16],  # PA12\n    [1, 20],  # PA13\n    [1, 24],  # PA14\n    [1, 28],  # PA15\n    [2, 0],  # PA16\n    [2, 4],  # PA17\n    [2, 8],  # PA18\n    [2, 12],  # PA19\n    [2, 16],  # PA20\n    [2, 20],  # PA21\n]\n\n# 寄存器基础地址\nALLWINNER_H3_BASE = 0x01C20000\n# GPIO_A 相对于 ALLWINNER_H3_BASE 偏移量\nGPIO_PA_OFFSET = 0x0800\n# 指定在使用 mmap 函数时要映射的区域大小\nMMAP_SIZE = 0x1000\n# GPIO 模式设定\nINPUT = 0\nOUTPUT = 1\n# GPIO 电平设定\nLOW = 0\nHIGH = 1\n# 上拉下拉设定\nPULL_OFF = 0\nPULL_UP = 1\nPULL_DOWN = 2\n\n\n# GPIO 端口寄存器类型\nclass gpio_t(Structure):\n    _fields_ = [\n        (\"config\", c_uint32 * 4),\n        (\"data\", c_uint32),\n        (\"driver\", c_uint32 * 2),\n        (\"pull\", c_uint32 * 2),\n    ]\n\n\n# 配置 GPIO_A 的指定管脚为输出模式\ndef set_output(gpio: Type[gpio_t], pin: int) -> None:\n    # 取得寄存器号与寄存器位\n    reg, bit = GPIO_A_CONFIG[pin]\n    # 清空原有配置\n    gpio.config[reg] &= ~(0x0F << bit)\n    # 设为输出模式\n    gpio.config[reg] |= (OUTPUT << bit)\n\n\n# 配置 GPIO_A 的指定管脚为输入模式\ndef set_input(gpio: Type[gpio_t], pin: int) -> None:\n    # 取得寄存器号与寄存器位\n    reg, bit = GPIO_A_CONFIG[pin]\n    # 清空原有配置\n    gpio.config[reg] &= ~(0x0F << bit)\n    # 设为输入模式\n    gpio.config[reg] |= (INPUT << bit)\n\n\n# 设定 GPIO_A 的指定管脚上拉下拉\ndef set_pull(gpio: Type[gpio_t], pin: int, pull: int) -> None:\n    # 取得寄存器号\n    reg = int(pin / 16)\n    # 取得寄存器位\n    bit = int((pin % 16) * 2)\n    # 清除原有配置\n    gpio.pull[reg] &= ~(0x03 << bit)\n    # 设置上拉下拉\n    gpio.pull[reg] |= (pull << bit)\n\n\n# 设定 GPIO_A 的指定管脚电平\ndef set_level(gpio: Type[gpio_t], pin: int, level: int) -> None:\n    if level == HIGH:\n        gpio.data |= (1 << pin)\n    elif level == LOW:\n        gpio.data &= ~(1 << pin)\n\n\n# 读取 GPIO_A 的指定管脚电平\ndef get_level(gpio: Type[gpio_t], pin: int) -> int:\n    # 取得寄存器号与寄存器位\n    reg, bit = GPIO_A_CONFIG[pin]\n    # 清空原有配置\n    gpio.config[reg] &= ~(0x0F << bit)\n    return (gpio.data >> pin) & 0x01\n\n\ndef main():\n    # 以读写模式打开 /dev/mem 装置文件\n    mem = open(\"/dev/mem\", O_RDWR | O_SYNC)\n    if mem < 0:\n        print(\"Failed to open /dev/mem\")\n        exit(1)\n\n    # 将寄存器映射到内存\n    reg = mmap(\n        mem, MMAP_SIZE, MAP_SHARED,\n        PROT_READ | PROT_WRITE,\n        offset=ALLWINNER_H3_BASE\n    )\n\n    # 将映射的地址偏移量应用于 GPIO_A 寄存器类型\n    gpio = gpio_t.from_buffer(reg, GPIO_PA_OFFSET)\n\n    # 设定 GPIO_A21 为输出模式\n    set_output(gpio, 21)\n    # 设定 GPIO_A8 为输入模式\n    set_input(gpio, 8)\n    # 设定 GPIO_A8 上拉使能\n    set_pull(gpio, 8, PULL_UP)\n\n    # 闪烁 LED 灯并读取电平\n    while True:\n        # 闪烁 GPIO_A21 LED\n        set_level(gpio, 21, HIGH)\n        sleep(0.5)\n        set_level(gpio, 21, LOW)\n        sleep(0.5)\n        # 读取 GPIO_A8 电平并打印\n        level = get_level(gpio, 8)\n        print(\"GPIO_A8 level:\", level)\n\n    # 解除内存映射\n    reg.close()\n    close(mem)\n\n\nif __name__ == \"__main__\":\n    main()\n```\n\n# 效果展示\n\n![GPIO_A21 闪烁的 LED](https://c.ibcl.us/OrangePi-MMAP_20230520/2.gif)\n\n![读取 GPIO_A8 电平](https://c.ibcl.us/OrangePi-MMAP_20230520/3.png)\n","words":15073}