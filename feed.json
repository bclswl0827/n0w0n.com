{
    "version": "https://jsonfeed.org/version/1",
    "title": "The [object Object]",
    "home_page_url": "httpsn0w0n.com/",
    "feed_url": "https://n0w0n.com/feed.json",
    "icon": "/avatar.jpg",
    "author": {
        "name": "Unknown netizen"
    },
    "items": [
        {
            "id": "seiscomp_plugin_impl_in_go",
            "content_html": "<p>It has been a few months since I left Seeed Studio and started working on my own business, <a href=\"https://anyshake.org\">AnyShake Project</a>, a open-source project targeted at Raspberry Shake and other similar products.</p>\n<p>As part of building a complete seismograph solution — both hardware and software — I knew from the beginning that integration with SeisComP was a must. It's one of the most widely used tools in professional seismology for real-time monitoring, data acquisition, and event detection. However, most SeisComP plugins are traditionally written in either C++ or Python. And to be honest, after years of juggling build systems, header hell, and Python dependency management, I decided: not this time.</p>\n<h2 id=\"thechallenge\">The Challenge</h2>\n<p>SeisComP's plugin system is designed with C, C++, and Python in mind. There's no official plugin SDK for Go — actually, no SDKs at all — and the documentation is painfully sparse when it comes to writing custom data sources.</p>\n<p>To be honest, after getting used to modern developer tools and documentation with quick starts, examples, and real-world use cases, reading the SeisComP docs felt like stepping back in time. Instead of showing you how to get something working quickly, it starts with every possible concept, explained in abstract detail. I get that it's thorough, but when all I wanted was \"how do I feed my waveform into the system?\"—it was a slog.</p>\n<p>I don’t need a philosophical discussion on the nature of a stream; I need a working data pipeline.</p>\n<p>So I decided to do it the hard way: dive into the source code, trace how existing modules talk to each other, and build my own minimal setup from scratch.</p>\n<h2 id=\"whygo\">Why Go?</h2>\n<p>Go (or Golang) has become my go-to language for building everything from firmware tools to backend services. It compiles to a single binary, it's cross-platform friendly, and concurrency is baked into the language. Most importantly, it allows me to move fast without sacrificing stability or maintainability. So the question became: can I write a fully functional SeisComP plugin in pure Go—no C bindings, no Python wrappers?</p>\n<blockquote>\n  <p>Spoiler alert: yes, I can.</p>\n</blockquote>\n<h2 id=\"analysisanddesign\">Analysis and Design</h2>\n<p>Seismograph manufacturers are scattered across the globe, and most of them use their own proprietary protocols. To accommodate this diversity, SeisComP adopts an interface-oriented design pattern: it provides two files, <a href=\"https://github.com/SeisComP/seedlink/blob/master/libs/plugin/plugin.c\"><code>plugin.c</code></a> and <a href=\"https://github.com/SeisComP/seedlink/blob/master/libs/plugin/plugin.h\"><code>plugin.h</code></a>, allowing users to implement specific function signatures (such as <code>send_raw3</code>) themselves. Once implemented, users can register their plugin within SeisComP, enabling dynamic loading of data sources without modifying the SeisComP core.</p>\n<p>This is a particularly clever approach because it elegantly decouples third-party data ingestion from the core system. By examining the source code of <code>plugin.c</code>, we can see that the final call chain is as follows:</p>\n<pre><code>send_raw3\n  ↓\n  ├─ Prepare and populate header fields (station, channel, time, correction...)\n  ↓\n  ├─ If no data is available:\n  │     ├─ Send a time packet (PluginRawDataTimePacket)\n  │     └─ Or send a GAP packet (PluginRawDataGapPacket)\n  ↓\n  ├─ Loop and send data in fragments:\n  │     ├─ head.packtype = TimePacket (first packet) / DataPacket (subsequent packets)\n  │     ├─ head.data_size = sample_count\n  │     └─ Call send_packet()\n  │           ↓\n  │           ├─ writen(PLUGIN_FD, head)\n  │           └─ writen(PLUGIN_FD, dataptr)\n  ↓\n  └─ Return the total number of bytes sent\n</code></pre>\n<p>Here, <code>PLUGIN_FD</code> is defined as <code>63</code> — a predefined constant in SeisComP’s SeedLink plugin system. It represents a special file descriptor used as an IPC \"pipe\" for communication between the plugin and SeisComP.</p>\n<p>This insight reveals an important fact: if we can replicate this process, we can implement a fully functional SeisComP plugin in Go.</p>\n<p>In the case of AnyShake Observer, the software already provides a TCP-based data forwarder. This means that all I need to do is connect to the server, receive and parse the incoming data, and then format and send it according to SeisComP’s expected protocol.</p>\n<h2 id=\"implementation\">Implementation</h2>\n<p>Initially, I considered calling the C functions directly via cgo, but ultimately, due to cross-compilation concerns, I decided to translate the prototypes into pure Go code—after all, they aren’t particularly complex. I created a struct that encapsulates the file descriptor and exposed the following methods:</p>\n<ul>\n<li>SendRaw3</li>\n<li>SendFlush3</li>\n<li>SendMSeed</li>\n<li>SendMSeed2</li>\n<li>SendLog3</li>\n<li>SendRawDepoch</li>\n</ul>\n<p>They maintain the same function signatures as in C, but are implemented entirely in pure Go, requiring no cgo support and thus can be called directly from Go. The final code is as follows:</p>\n<pre><code class=\"go language-go\">import (\n    \"encoding/binary\"\n    \"os\"\n    \"time\"\n)\n\nconst (\n    PLUGIN_FD             = 63\n    PLUGIN_MSEED_SIZE     = 512\n    PLUGIN_MAX_MSG_SIZE   = 448\n    PLUGIN_MAX_DATA_BYTES = 4000\n)\n\nconst (\n    PLUGIN_RAW_TIME_PACKET  = 8\n    PLUGIN_RAW_PACKET       = 9\n    PLUGIN_RAW_GAP_PACKET   = 10\n    PLUGIN_RAW_FLUSH_PACKET = 11\n    PLUGIN_LOG_PACKET       = 12\n    PLUGIN_MSEED_PACKET     = 13\n)\n\ntype PluginPacketHeader struct {\n    PackType       uint32\n    Station        [10]byte\n    Channel        [10]byte\n    Year           uint32\n    Yday           uint32\n    Hour           uint32\n    Minute         uint32\n    Second         uint32\n    Usec           uint32\n    UsecCorrection int32\n    TimingQuality  int32\n    DataSize       int32\n}\n\ntype SeedLinkPluginIPC struct {\n    fd *os.File\n}\n\nfunc NewSeedlinkPluginIPC() SeedLinkPluginIPC {\n    return SeedLinkPluginIPC{\n        fd: os.NewFile(PLUGIN_FD, \"seedlink\"),\n    }\n}\n\nfunc (s *SeedLinkPluginIPC) sendPacket(head *PluginPacketHeader, data []byte) error {\n    headerBuf := make([]byte, 60)\n\n    binary.LittleEndian.PutUint32(headerBuf[0:4], head.PackType)\n    copy(headerBuf[4:14], head.Station[:])\n    copy(headerBuf[14:24], head.Channel[:])\n    binary.LittleEndian.PutUint32(headerBuf[24:28], head.Year)\n    binary.LittleEndian.PutUint32(headerBuf[28:32], head.Yday)\n    binary.LittleEndian.PutUint32(headerBuf[32:36], head.Hour)\n    binary.LittleEndian.PutUint32(headerBuf[36:40], head.Minute)\n    binary.LittleEndian.PutUint32(headerBuf[40:44], head.Second)\n    binary.LittleEndian.PutUint32(headerBuf[44:48], head.Usec)\n    binary.LittleEndian.PutUint32(headerBuf[48:52], uint32(head.UsecCorrection))\n    binary.LittleEndian.PutUint32(headerBuf[52:56], uint32(head.TimingQuality))\n    binary.LittleEndian.PutUint32(headerBuf[56:60], uint32(head.DataSize))\n\n    if _, err := s.fd.Write(headerBuf); err != nil {\n        return err\n    }\n    if data != nil {\n        if _, err := s.fd.Write(data); err != nil {\n            return err\n        }\n    }\n\n    return nil\n}\n\nfunc (s *SeedLinkPluginIPC) isLeap(y int) bool {\n    return (y%400 == 0) || (y%4 == 0 &amp;&amp; y%100 != 0)\n}\n\nfunc (s *SeedLinkPluginIPC) ldoy(y, m int) int {\n    doy := [...]int{0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365}\n    if s.isLeap(y) &amp;&amp; m &gt;= 3 {\n        return doy[m-1] + 1\n    }\n    return doy[m-1]\n}\n\nfunc (s *SeedLinkPluginIPC) mdy2dy(month, day, year int) int {\n    return s.ldoy(year, month) + day - 1\n}\n\nfunc (s *SeedLinkPluginIPC) Close() {\n    _ = s.fd.Close()\n}\n\nfunc (s *SeedLinkPluginIPC) SendRaw3(station, channel string, t time.Time, usecCorr, timingQuality int, data []int32) error {\n    const maxSamplesPerPacket = PLUGIN_MAX_DATA_BYTES / 4 // 4000 / 4 = 1000\n\n    sent := 0\n    total := len(data)\n    first := true\n\n    for sent &lt; total {\n        end := sent + maxSamplesPerPacket\n        if end &gt; total {\n            end = total\n        }\n        chunk := data[sent:end]\n\n        var head PluginPacketHeader\n        copy(head.Station[:], station)\n        copy(head.Channel[:], channel)\n\n        if first {\n            head.PackType = PLUGIN_RAW_TIME_PACKET\n            head.Year = uint32(t.Year())\n            head.Yday = uint32(s.mdy2dy(int(t.Month()), t.Day(), t.Year()))\n            head.Hour = uint32(t.Hour())\n            head.Minute = uint32(t.Minute())\n            head.Second = uint32(t.Second())\n            head.Usec = uint32(t.Nanosecond() / 1000)\n            head.UsecCorrection = int32(usecCorr)\n            head.TimingQuality = int32(timingQuality)\n            first = false\n        } else {\n            head.PackType = PLUGIN_RAW_PACKET\n        }\n\n        head.DataSize = int32(len(chunk))\n\n        dataBytes := make([]byte, len(chunk)*4)\n        for i, v := range chunk {\n            binary.LittleEndian.PutUint32(dataBytes[i*4:(i+1)*4], uint32(v))\n        }\n\n        if err := s.sendPacket(&amp;head, dataBytes); err != nil {\n            return err\n        }\n\n        sent = end\n    }\n\n    return nil\n}\n\nfunc (s *SeedLinkPluginIPC) SendFlush3(station, channel string) error {\n    var head PluginPacketHeader\n    copy(head.Station[:], station)\n    copy(head.Channel[:], channel)\n    head.PackType = PLUGIN_RAW_FLUSH_PACKET\n    head.DataSize = 0\n\n    return s.sendPacket(&amp;head, nil)\n}\n\nfunc (s *SeedLinkPluginIPC) SendMSeed(station string, data []byte) error {\n    if len(data) != PLUGIN_MSEED_SIZE {\n        return nil\n    }\n\n    var head PluginPacketHeader\n    copy(head.Station[:], station)\n    head.PackType = PLUGIN_MSEED_PACKET\n    head.DataSize = int32(len(data))\n\n    return s.sendPacket(&amp;head, data)\n}\n\nfunc (s *SeedLinkPluginIPC) SendMSeed2(station, channel string, seq int, data []byte) error {\n    if len(data) != PLUGIN_MSEED_SIZE {\n        return nil\n    }\n\n    var head PluginPacketHeader\n    copy(head.Station[:], station)\n    copy(head.Channel[:], channel)\n    head.PackType = PLUGIN_MSEED_PACKET\n    head.TimingQuality = int32(seq)\n    head.DataSize = int32(len(data))\n\n    return s.sendPacket(&amp;head, data)\n}\n\nfunc (s *SeedLinkPluginIPC) SendLog3(station string, t time.Time, msg string) error {\n    var head PluginPacketHeader\n    copy(head.Station[:], station)\n    head.PackType = PLUGIN_LOG_PACKET\n\n    head.Year = uint32(t.Year())\n    head.Yday = uint32(s.mdy2dy(int(t.Month()), t.Day(), t.Year()))\n    head.Hour = uint32(t.Hour())\n    head.Minute = uint32(t.Minute())\n    head.Second = uint32(t.Second())\n    head.Usec = uint32(t.Nanosecond() / 1000)\n\n    data := []byte(msg)\n    head.DataSize = int32(len(data))\n\n    return s.sendPacket(&amp;head, data)\n}\n\nfunc (s *SeedLinkPluginIPC) SendRawDepoch(station, channel string, depoch float64, usecCorr, timingQuality int, data []int32) error {\n    sec := int64(depoch)\n    usec := int((depoch - float64(sec)) * 1e6)\n    t := time.Unix(sec, int64(usec)*1000).UTC()\n    return s.SendRaw3(station, channel, t, usecCorr, timingQuality, data)\n}\n</code></pre>\n<p>In the AnyShake Project, the AnyShake Explorer — used as a data acquisition device—can experience gradual clock drift due to tiny deviations in its crystal oscillator. To address this, I chose to use <code>SendMSeed</code> to provide the data, ensuring that each data packet carries a fully controllable timestamp.</p>\n<p>The function <code>SendMSeed</code> only accepts pre-encoded MiniSEED packets, so I leveraged a pure Go MiniSEED encoding library I previously developed for the AnyShake Project, <a href=\"https://github.com/bclswl0827/mseedio\">mseedio</a>, to handle this task.</p>\n<p>It’s important to note that, according to the implementation in <code>plugin.c</code>, each MiniSEED packet written to <code>SendMSeed</code> must have a length equal to <code>PLUGIN_MSEED_SIZE</code>, i.e., 512 bytes. Through extensive testing, I found that MiniSEED packets containing 100 samples are safe. Therefore, I set 100 samples as the upper limit for a single MiniSEED data block. Before encoding, I check the data length and slice it appropriately. I also encapsulated the MiniSEED encoding logic to make it easier to use.</p>\n<pre><code class=\"go language-go\">import (\n    \"fmt\"\n    \"time\"\n\n    \"github.com/bclswl0827/mseedio\"\n)\n\nconst MINISEED_CHUNK_SAMPLES = 100\n\ntype MiniSeedData struct {\n    Station    string\n    Network    string\n    Location   string\n    Channel    string\n    Timestamp  int64\n    SampleRate int\n    Data       []int32\n}\n\nfunc NewMiniSeedData(timestamp time.Time, station, network, location, channel string, sampleRate int, data []int32) MiniSeedData {\n    return MiniSeedData{\n        Timestamp:  timestamp.UnixMilli(),\n        Station:    station,\n        Network:    network,\n        Location:   location,\n        Channel:    channel,\n        SampleRate: sampleRate,\n        Data:       data,\n    }\n}\n\nfunc (m *MiniSeedData) chunkInt32Slice(data []int32, chunkSamples int) [][]int32 {\n    var chunks [][]int32\n\n    for i := 0; i &lt; len(data); i += chunkSamples {\n        end := min(i+chunkSamples, len(data))\n        chunks = append(chunks, data[i:end])\n    }\n\n    return chunks\n}\n\nfunc (m *MiniSeedData) EncodeChunk(sequenceNumber int) ([][]byte, error) {\n    dataSpanMs := 1000 / m.SampleRate\n    var buf [][]byte\n\n    for i, c := range m.chunkInt32Slice(m.Data, MINISEED_CHUNK_SAMPLES) {\n        var miniseed mseedio.MiniSeedData\n        if err := miniseed.Init(mseedio.STEIM2, mseedio.MSBFIRST); err != nil {\n            return nil, err\n        }\n\n        startTime := time.UnixMilli(m.Timestamp + int64(i*MINISEED_CHUNK_SAMPLES*dataSpanMs)).UTC()\n        if err := miniseed.Append(c, &amp;mseedio.AppendOptions{\n            ChannelCode:    m.Channel,\n            StationCode:    m.Station,\n            LocationCode:   m.Location,\n            NetworkCode:    m.Network,\n            SampleRate:     float64(m.SampleRate),\n            SequenceNumber: fmt.Sprintf(\"%06d\", sequenceNumber),\n            StartTime:      startTime,\n        }); err != nil {\n            return nil, err\n        }\n\n        for i := 0; i &lt; len(miniseed.Series); i++ {\n            miniseed.Series[i].BlocketteSection.RecordLength = 9\n        }\n\n        msData, err := miniseed.Encode(mseedio.OVERWRITE, mseedio.MSBFIRST)\n        if err != nil {\n            return nil, err\n        }\n\n        buf = append(buf, msData)\n    }\n\n    return buf, nil\n}\n</code></pre>\n<p>The above covers the core code analysis. For establishing the TCP connection, the main program, and some necessary template files, I have open-sourced everything in the <a href=\"https://github.com/anyshake/nexus\">AnyShake Nexus</a> repository. The code is simple and easy to read, so I won’t go into further detail here.</p>\n<h2 id=\"testresult\">Test Result</h2>\n<p>I configured the AnyShake Nexus plugin as a data source in SeisComP.</p>\n<p><img src=\"https://assets.n0w0n.com/seiscomp_plugin_impl_in_go/1.png\" alt=\"SeisComP Configuration\" /></p>\n<p>After starting the SeedLink module and checking the logs, it is clear that the system correctly recognizes the data stream coming from the plugin.</p>\n<p><img src=\"https://assets.n0w0n.com/seiscomp_plugin_impl_in_go/2.png\" alt=\"SeedLink Module\" /></p>\n<p>Opening a terminal and running <code>scrttv</code> shows the real-time waveform from the plugin—mission accomplished.</p>\n<p><img src=\"https://assets.n0w0n.com/seiscomp_plugin_impl_in_go/3.png\" alt=\"Realtime Waveform\" /></p>",
            "url": "https://n0w0n.com/post/seiscomp_plugin_impl_in_go",
            "title": "No C, No Python, No Problem: Writing a SeisComP Plugin in Pure Go",
            "summary": "<p>It has been a few months since I left Seeed Studio and started working on my own business, <a href=\"https://anyshake.org\">AnyShake Project</a>, a open-source project targeted at Raspberry Shake and other similar products.</p>\n<p>As part of building a complete seismograph solution — both hardware and software — I knew from the beginning that integration with SeisComP was a must. It's one of the most widely used tools in professional seismology for real-time monitoring, data acquisition, and event detection. However, most SeisComP plugins are traditionally written in either C++ or Python. And to be honest, after years of juggling build systems, header hell, and Python dependency management, I decided: not this time.</p>\n<h2 id=\"thechallenge\">The Challenge</h2>\n<p>SeisComP's plugin system is designed with C, C++, and Python in mind. There's no official plugin SDK for Go — actually, no SDKs at all — and the documentation is painfully sparse when it comes to writing custom data sources.</p>\n<p>To be honest, after getting used to modern developer tools and documentation with quick starts, examples, and real-world use cases, reading the SeisComP docs felt like stepping back in time. Instead of showing you how to get something working quickly, it starts with every possible concept, explained in abstract detail. I get that it's thorough, but when all I wanted was \"how do I feed my waveform into the system?\"—it was a slog.</p>\n<p>I don’t need a philosophical discussion on the nature of a stream; I need a working data pipeline.</p>\n<p>So I decided to do it the hard way: dive into the source code, trace how existing modules talk to each other, and build my own minimal setup from scratch.</p>\n<h2 id=\"whygo\">Why Go?</h2>\n<p>Go (or Golang) has become my go-to language for building everything from firmware tools to backend services. It compiles to a single binary, it's cross-platform friendly, and concurrency is baked into the language. Most importantly, it allows me to move fast without sacrificing stability or maintainability. So the question became: can I write a fully functional SeisComP plugin in pure Go—no C bindings, no Python wrappers?</p>\n<blockquote>\n  <p>Spoiler alert: yes, I can.</p>\n</blockquote>",
            "date_modified": "2025-09-24T05:08:00.000Z"
        },
        {
            "id": "the_60000_usd_patch_is_a_triumph",
            "content_html": "<p>In mid-October, after three rounds of assessments and interviews, I finally get a work from a company that specializing in open-source IoT and embedded development.</p>\n<p>As an application engineer at this company, my responsibilities include building libraries, maintaining product documentation on the wiki, and creating customized demos for various edge computing devices. Just a few days into the role, I learned about a legacy issue with one of the products. Specifically, the RS485 interfaces had a critical flaw that prevented the port from properly switching the data direction.</p>\n<p>The R&amp;D team had previously attempted to address this issue at the application layer by developing a utility tool called <code>rs485_DE</code> using C. This tool would open the original RS485 port (e.g., <code>/dev/ttyAMA2</code>), then create a new virtual serial port, and monitor data on the virtual port. It would then automatically toggle the chip's $\\overline{\\text{RE}}$ pin based on the data flow direction. However, this approach introduced a new issue: the higher baud rates, the more frequently data loss would occurr. The root cause was the tool's reliance on polling to check the buffers, coupled with the use of the <code>libgpiod</code> library to manipulate GPIOs for flow control, which was too slow to meet the performance requirements.</p>\n<p>Adding to the complexity, the RS485 transceiver chip used in the product was the TPT7487. On this chip, the $\\overline{\\text{RE}}$ pin is responsible for controlling the chip's mode - either receive or transmit. However, instead of being connected to dedicated DTR pins, the $\\overline{\\text{RE}}$ pin was wired to several general-purpose GPIO pins on the Compute Module 4 (CM4). Unfortunately, the kernel driver did not configure these GPIOs as DTR pins, further limiting the ability to implement a hardware-based solution for automatic data direction control.</p>\n<p><img src=\"https://assets.n0w0n.com/the_60000_usd_patch_is_a_triumph/1.png\" alt=\"The general-purpose GPIO pins to RS485 transceiver chips\" />\n<img src=\"https://assets.n0w0n.com/the_60000_usd_patch_is_a_triumph/2.png\" alt=\"The RS485 transceiver schematic\" /></p>\n<p>After thorough discussions and evaluations, the team concluded that replacing all affected products was the only viable solution. Despite the significant cost - an estimated $60,000 - the company prioritized customer satisfaction and product reliability. With no better technical solution available, the recall decision was made to uphold the company's reputation and ensure long-term trust from customers.</p>\n<p>Out of curiosity, I requested the schematic of the product and, after some analysis, I surprisingly discovered what I believed could be a potential software solution to the issues. That marked the beginning of a new chapter in addressing the problem.</p>\n<h2 id=\"akernellevelapproachtotheissue\">A Kernel-Level Approach to the Issue</h2>\n<p>From the above schematic and the <a href=\"http://file.3peakic.com.cn:8080/product/Datasheet_TPT7487-TPT7488.pdf\">TPT7487 datasheet</a>, it became clear that when the CM4<em>RS485</em>n_DTR (where n = [1, 2, 3]) pins are low, the transceiver enters receive mode; when they are high, the chip switches to transmit mode.</p>\n<p>Since this product is based on the CM4, it is highly likely that most users would download and install the official Raspberry Pi OS image, which meant that modifying and redistributing the Raspberry Pi Linux kernel driver would be impractical. This approach would introduce significant inconvenience for users - especially since we don't even have an independent apt source!</p>\n<p>Now the problem was clear: a solution that required kernel changes or custom distribution wouldn't work in this environment.</p>\n<p>As I continued to think about the issue, I realized that I could write an out-of-tree kernel module to control the $\\overline{\\text{RE}}$ pin and thus achieve automatic toggling of the transceiver mode. However, the challenge was to implement this solution without relying on polling, which had been a major flaw in the original approach. At the time, I didn't have much experience with kernel modules, but I decided to take a chance and try to solve it.</p>\n<p>I recalled an idea I had seen previously in server monitoring tools, where file changes could be tracked by hooking into the syscall layer. Inspired by this concept, I figured I could apply the same principle to monitor the UART calls and control the $\\overline{\\text{RE}}$ pin's state. Instead of polling, I thought I could hook into the relevant functions that handle data transmission and reception, allowing me to change the pin's state dynamically in response to the data flow direction.</p>\n<p>By leveraging this approach, I aimed to develop a solution that was both efficient and non-intrusive, providing a clean software-level fix without needing to modify the underlying kernel or disrupt the user experience.</p>\n<h2 id=\"thechallengeswithkernelmodifications\">The Challenges with Kernel Modifications</h2>\n<p>As I began exploring potential solutions to hook syscalls, I encountered a significant challenge with the existing syscall hook implementations. Many of the examples I found were designed for kernel versions prior to 5.7. This limitation stemmed from the fact that, starting from kernel 5.7, the <code>kallsyms_lookup_name</code> function was no longer exported, which meant the approach of directly searching for kernel symbols by name wouldn't work.</p>\n<p>After researching alternatives, I discovered that the kprobe mechanism could be used to achieve the same goal. The kprobe is a powerful tool in the Linux kernel that allows for dynamic instrumentation of functions at runtime. By using kprobe, I could locate and interact with kernel symbols (such as syscalls) even on newer kernels where <code>kallsyms_lookup_name</code> is not available. This discovery provided a way to work around the limitations of newer kernel versions.</p>\n<p>With this in mind, I proceeded to write a kernel module to implement syscall hooking using kprobe. The following code demonstrates how to hook the <code>mkdir</code> syscall, replacing it with a custom version. The module dynamically locates kernel symbols using kprobe, bypassing the restriction imposed by kernel 5.7 and above.</p>\n<p>BTW, The following code is designed to work with ARM64 architecture. For x86_64 architecture, <a href=\"https://github.com/bclswl0827/linux-syscall-hook-mkdir/tree/master\">the full demo has been provided on GitHub</a>.</p>\n<pre><code class=\"cpp language-cpp\">#include &lt;asm/unistd.h&gt;\n#include &lt;linux/kallsyms.h&gt;\n#include &lt;linux/kernel.h&gt;\n#include &lt;linux/kprobes.h&gt;\n#include &lt;linux/module.h&gt;\n#include &lt;linux/version.h&gt;\n#include &lt;linux/vmalloc.h&gt;\n\n#define MODULE_NAME \"syscall_hook\"\n#define LOG_PREFIX MODULE_NAME \": \"\n\nMODULE_DESCRIPTION(\"A simple module that hooks the `mkdir` function, works on kernel 5.7 and higher.\");\nMODULE_AUTHOR(\"Joshua Lee &lt;chengxun.li@seeed.cc&gt;\");\nMODULE_LICENSE(\"Dual MIT/GPL\");\nMODULE_VERSION(\"0.0.1\");\n\n// For Linux 5.7 and higher versions, `kallsyms_lookup_name` is not exported anymore.\n// But we can use `kprobe` to find the address of `kallsyms_lookup_name`.\n// The `custom_kallsyms_lookup_name` represents the address of `kallsyms_lookup_name` internally.\n// For kernel 5.7 and below, the `custom_kallsyms_lookup_name` simply calls to `kallsyms_lookup_name`.\n#if LINUX_VERSION_CODE &gt;= KERNEL_VERSION(5, 7, 0)\ntypedef unsigned long (*kallsyms_lookup_name_t)(const char* name);\nstatic kallsyms_lookup_name_t custom_kallsyms_lookup_name;\n#else\n#define custom_kallsyms_lookup_name kallsyms_lookup_name\n#endif\n\n// `fixup_kallsyms_lookup_name` extracts the address of `kallsyms_lookup_name` from `kprobe`.\n// It returns 0 on success, -EFAULT on failure.\nstatic int fixup_kallsyms_lookup_name(void) {\n#if LINUX_VERSION_CODE &gt;= KERNEL_VERSION(5, 7, 0)\n    struct kprobe kp = {.symbol_name = \"kallsyms_lookup_name\"};\n    int result = register_kprobe(&amp;kp);\n    if (result &lt; 0) {\n        printk(KERN_ERR LOG_PREFIX \"Failed to register kprobe, returned code: %d\\n\", result);\n        return result;\n    }\n    custom_kallsyms_lookup_name = (kallsyms_lookup_name_t)kp.addr;\n    unregister_kprobe(&amp;kp);\n    if (!custom_kallsyms_lookup_name) {\n        printk(KERN_ERR LOG_PREFIX \"Failed to get address for `kallsyms_lookup_name`\\n\");\n        return -EFAULT;\n    }\n    printk(KERN_DEBUG LOG_PREFIX \"Got address for `kallsyms_lookup_name`: %p\\n\", custom_kallsyms_lookup_name);\n    return 0;\n#else\n    return 0;\n#endif\n}\n\nstruct vm_struct* (*custom_find_vm_area)(const void* base_addr);      // `custom_find_vm_area` points to the address of `find_vm_area` function.\nint (*custom_set_memory_rw)(unsigned long base_addr, int num_pages);  // `custom_set_memory_rw` points to the address of `set_memory_rw` function.\nint (*custom_set_memory_ro)(unsigned long base_addr, int num_pages);  // `custom_set_memory_ro` points to the address of `set_memory_ro` function.\nstatic unsigned long syscall_target_base_addr;                        // `syscall_target_base_addr` is the base address of target syscall.\n\ntypedef long (*syscall_fn_t)(const struct pt_regs* regs);  // `syscall_fn_t` is the type of any syscall.\nstatic syscall_fn_t prototype_mkdir;                       // `prototype_mkdir` is backup of original `mkdir` function.\nstatic unsigned long* syscall_table;                       // `syscall_table` points to the address of `sys_call_table`.\n\n// `custom_mkdir` is our custom `mkdir` function.\n// Do whatever you want here and return the result.\nstatic int custom_mkdir(const struct pt_regs* regs) {\n    char filename[512] = {0};\n    char __user* pathname = (char*)regs-&gt;regs[1];\n    if (copy_from_user(filename, pathname, sizeof(filename)) != 0) {\n        printk(KERN_ERR LOG_PREFIX \"Failed to get file name from user\\n\");\n        return -1;\n    }\n    printk(KERN_INFO LOG_PREFIX \"`mkdir` function called by user, file name: %s\\n\", filename);\n    return prototype_mkdir(regs);  // Call original `mkdir`.\n}\n\nstatic int module_init_fn(void) {\n    if (fixup_kallsyms_lookup_name() &lt; 0) {\n        return -1;\n    }\n\n    custom_set_memory_ro = (void*)custom_kallsyms_lookup_name(\"set_memory_ro\");\n    if (custom_set_memory_ro == NULL) {\n        printk(KERN_ERR LOG_PREFIX \"Could not find `set_memory_ro`\\n\");\n        return -1;\n    }\n\n    custom_set_memory_rw = (void*)custom_kallsyms_lookup_name(\"set_memory_rw\");\n    if (custom_set_memory_rw == NULL) {\n        printk(KERN_ERR LOG_PREFIX \"Could not find `set_memory_rw`\\n\");\n        return -1;\n    }\n\n    custom_find_vm_area = (void*)custom_kallsyms_lookup_name(\"find_vm_area\");\n    if (custom_find_vm_area == NULL) {\n        printk(KERN_ERR LOG_PREFIX \"Could not find `find_vm_area`\\n\");\n        return -1;\n    }\n\n    syscall_table = (unsigned long*)custom_kallsyms_lookup_name(\"sys_call_table\");\n    if (syscall_table == NULL) {\n        printk(KERN_ERR LOG_PREFIX \"Could not find `sys_call_table`\\n\");\n        return -1;\n    }\n    prototype_mkdir = (syscall_fn_t)syscall_table[__NR_mkdirat];  // Create backup of original `mkdir` function.\n\n    syscall_target_base_addr = ((unsigned long)(syscall_table + __NR_mkdirat)) &amp; PAGE_MASK;\n    struct vm_struct* area = custom_find_vm_area((void*)syscall_target_base_addr);\n    if (area == NULL) {\n        printk(KERN_ERR LOG_PREFIX \"Could not find vm area\\n\");\n        return -1;\n    }\n    area-&gt;flags |= VM_ALLOC;\n\n    int result = custom_set_memory_rw(syscall_target_base_addr, 1);\n    if (result != 0) {\n        printk(KERN_ERR LOG_PREFIX \"Failed to set memory to read/write mode\\n\");\n        return -1;\n    }\n    syscall_table[__NR_mkdirat] = (unsigned long)custom_mkdir;  // Replace original `mkdir` with our custom one.\n    result = custom_set_memory_ro(syscall_target_base_addr, 1);\n    if (result != 0) {\n        printk(KERN_ERR LOG_PREFIX \"Failed to set memory to read-only mode\\n\");\n        return -1;\n    }\n\n    printk(KERN_INFO LOG_PREFIX \"Hooked `mkdir` function successfully (%p =&gt; %p)\\n\", prototype_mkdir, custom_mkdir);\n    return 0;\n}\n\nstatic void module_end_fn(void) {\n    int result = custom_set_memory_rw(syscall_target_base_addr, 1);\n    if (result != 0) {\n        printk(KERN_ERR LOG_PREFIX \"Failed to set memory to read/write mode\\n\");\n        return;\n    }\n    syscall_table[__NR_mkdirat] = (unsigned long)prototype_mkdir;  // Restore original `mkdir` function.\n    result = custom_set_memory_ro(syscall_target_base_addr, 1);\n    if (result != 0) {\n        printk(KERN_ERR LOG_PREFIX \"Failed to set memory to read-only mode\\n\");\n        return;\n    }\n\n    printk(KERN_INFO LOG_PREFIX \"Unhooked `mkdir` function successfully (%p =&gt; %p)\\n\", custom_mkdir, prototype_mkdir);\n}\n\nmodule_init(module_init_fn);\nmodule_exit(module_end_fn);\n</code></pre>\n<p><img src=\"https://assets.n0w0n.com/the_60000_usd_patch_is_a_triumph/3.png\" alt=\"Hook loaded\" /></p>\n<p>Cheers!</p>\n<h2 id=\"happyhackingwithkprobes\">Happy Hacking with Kprobes</h2>\n<p>Over the next few days, I broke down the task into smaller steps and gradually implemented the required functionality:</p>\n<ol>\n<li>Set GPIO Mode and Control Pin Levels in the Kernel Module</li>\n<li>Hook <code>uart_write</code> in the Kernel Module to Raise GPIO Before Transmission</li>\n<li>Wait for <code>uart_write</code> Completion and Lower GPIO After Transmission</li>\n</ol>\n<p><a href=\"https://n0w0n.com/#/post/allwinner_h3_memory_mapping\">Thanks to an article I wrote in 2023 on using mmap for GPIO control</a>, I successfully implemented GPIO control in a Raspberry Pi kernel module. The final code is as follows, <a href=\"https://github.com/bclswl0827/r1000v1-rs485-autoflow\">I also made it public on my GitHub repository</a>.</p>\n<pre><code class=\"cpp language-cpp\">#include &lt;asm/io.h&gt;\n#include &lt;linux/delay.h&gt;\n#include &lt;linux/kprobes.h&gt;\n#include &lt;linux/slab.h&gt;\n#include &lt;linux/tty.h&gt;\n#include &lt;linux/workqueue.h&gt;\n\n#ifndef MODULE_NAME\n#define MODULE_NAME \"r1000v1_rs485_autoflow\"\n#endif\n\n#ifndef MODULE_VER\n#define MODULE_VER \"custom\"\n#endif\n\nMODULE_DESCRIPTION(\"This module fixes RS-485 flow control issue on reComputer R1000 v1.0 by hooking `uart_write` function.\");\nMODULE_AUTHOR(\"Joshua Lee &lt;chengxun.li@seeed.cc&gt;\");\nMODULE_LICENSE(\"Dual MIT/GPL\");\nMODULE_VERSION(MODULE_VER);\n\n#define BCM2711_GPIO_BASE (0xfe000000 + 0x200000)\n\nvolatile unsigned int* GPFSEL0;                  // Function selector for GPIO 0-9, for CM4_RS485_1_DTR at GPIO_6.\nvolatile unsigned int* GPFSEL1;                  // Function selector for GPIO 10-19, for CM4_RS485_2_DTR at GPIO_17.\nvolatile unsigned int* GPFSEL2;                  // Function selector for GPIO 20-29, for CM4_RS485_3_DTR at GPIO_24.\nvolatile unsigned int* GPSET0;                   // Register to set GPIO 0-31 to high.\nvolatile unsigned int* GPCLR0;                   // Register to set GPIO 0-31 to low.\nvolatile unsigned int* GPIO_PUP_PDN_CNTRL_REG0;  // Register to set pull up/down control of GPIO 0-15.\nvolatile unsigned int* GPIO_PUP_PDN_CNTRL_REG1;  // Register to set pull up/down control of GPIO 16-31.\n\nstatic void rs485_dtr_init(void) {\n    // Re-map GPIO registers, offsets are given in the datasheet\n    GPFSEL0 = (volatile unsigned int*)ioremap(BCM2711_GPIO_BASE + 0x00, 4);\n    GPFSEL1 = (volatile unsigned int*)ioremap(BCM2711_GPIO_BASE + 0x04, 4);\n    GPFSEL2 = (volatile unsigned int*)ioremap(BCM2711_GPIO_BASE + 0x08, 4);\n    GPSET0 = (volatile unsigned int*)ioremap(BCM2711_GPIO_BASE + 0x1c, 4);\n    GPCLR0 = (volatile unsigned int*)ioremap(BCM2711_GPIO_BASE + 0x28, 4);\n    GPIO_PUP_PDN_CNTRL_REG0 = (volatile unsigned int*)ioremap(BCM2711_GPIO_BASE + 0xe4, 4);\n    GPIO_PUP_PDN_CNTRL_REG1 = (volatile unsigned int*)ioremap(BCM2711_GPIO_BASE + 0xe8, 4);\n\n    // Set CM4_RS485_1_DTR at GPIO_6 to output mode (GPFSEL0[20:18]), no internal pull\n    *GPFSEL0 &amp;= ~(7 &lt;&lt; 18);\n    *GPFSEL0 |= (1 &lt;&lt; 18);\n    *GPIO_PUP_PDN_CNTRL_REG0 &amp;= ~(3 &lt;&lt; 12);\n    *GPIO_PUP_PDN_CNTRL_REG0 |= (0 &lt;&lt; 12);\n    // Set CM4_RS485_2_DTR at GPIO_17 to output mode (GPFSEL1[23:21]), no internal pull\n    *GPFSEL1 &amp;= ~(7 &lt;&lt; 21);\n    *GPFSEL1 |= (1 &lt;&lt; 21);\n    *GPIO_PUP_PDN_CNTRL_REG1 &amp;= ~(3 &lt;&lt; 2);\n    *GPIO_PUP_PDN_CNTRL_REG1 |= (0 &lt;&lt; 2);\n    // Set CM4_RS485_3_DTR at GPIO_24 to output mode (GPFSEL2[14:12]), no internal pull\n    *GPFSEL2 &amp;= ~(7 &lt;&lt; 12);\n    *GPFSEL2 |= (1 &lt;&lt; 12);\n    *GPIO_PUP_PDN_CNTRL_REG1 &amp;= ~(3 &lt;&lt; 16);\n    *GPIO_PUP_PDN_CNTRL_REG1 |= (0 &lt;&lt; 16);\n    // Set all DTR pins to low\n    *GPCLR0 = (1 &lt;&lt; 6) | (1 &lt;&lt; 17) | (1 &lt;&lt; 24);\n}\n\nstatic void rs485_dtr_deinit(void) {\n    // Set all DTR pins to low\n    *GPCLR0 = (1 &lt;&lt; 6) | (1 &lt;&lt; 17) | (1 &lt;&lt; 24);\n    // Unmap GPIO registers\n    iounmap(GPFSEL0);\n    iounmap(GPFSEL1);\n    iounmap(GPFSEL2);\n    iounmap(GPSET0);\n    iounmap(GPCLR0);\n    iounmap(GPIO_PUP_PDN_CNTRL_REG0);\n    iounmap(GPIO_PUP_PDN_CNTRL_REG1);\n}\n\nstatic bool rs485_is_builtin_dev(struct tty_struct* tty) {\n    // `ttyAMA` is for built-in RS-485 interface\n    return strcmp(tty-&gt;driver-&gt;name, \"ttyAMA\") == 0;\n}\n\nstatic void rs485_dtr_set(int dev_num, bool enable) {\n    switch (dev_num) {\n        case 2:  // ttyAMA2\n            if (enable) {\n                *GPSET0 = (1 &lt;&lt; 6);\n            } else {\n                *GPCLR0 = (1 &lt;&lt; 6);\n            }\n            break;\n        case 3:  // ttyAMA3\n            if (enable) {\n                *GPSET0 = (1 &lt;&lt; 17);\n            } else {\n                *GPCLR0 = (1 &lt;&lt; 17);\n            }\n            break;\n        case 5:  // ttyAMA5\n            if (enable) {\n                *GPSET0 = (1 &lt;&lt; 24);\n            } else {\n                *GPCLR0 = (1 &lt;&lt; 24);\n            }\n            break;\n    }\n}\n\nstatic int rs485_get_dev_num(struct tty_struct* tty) {\n    if (tty-&gt;index == 2 || tty-&gt;index == 3 || tty-&gt;index == 5) {\n        return tty-&gt;index;\n    }\n    return -EINVAL;\n}\n\nstruct rs485_worker_t {\n    struct delayed_work work;\n    struct tty_struct* tty;\n};\nstatic struct workqueue_struct* rs485_worker_queues[3];  // 3 queues for 3 RS-485 interfaces (ttyAMA2, ttyAMA3, ttyAMA5)\n\nstatic int rs485_get_worker_index(int dev_num) {\n    if (dev_num == 2) {\n        return 0;\n    } else if (dev_num == 3) {\n        return 1;\n    } else if (dev_num == 5) {\n        return 2;\n    }\n    return -EINVAL;\n}\n\nstatic void rs485_worker_oncomplete(struct work_struct* work) {\n    struct rs485_worker_t* rs485_worker = container_of(work, struct rs485_worker_t, work.work);\n    // Wait until data is sent out, then set DTR to low\n    if (rs485_worker-&gt;tty-&gt;ops-&gt;write_room(rs485_worker-&gt;tty) == 0) {\n        schedule_delayed_work(&amp;rs485_worker-&gt;work, usecs_to_jiffies(1));\n        return;\n    }\n\n    // Wait for some time before setting DTR to low, delay is based on baudrate\n    // Each character takes (10 * 1000 / baudrate) milliseconds\n    // Plus 60ns for transceiver mode switch (mentionned in TPT7487 datasheet) \n    int baudrate = tty_get_baud_rate(rs485_worker-&gt;tty);\n    msleep((10 * 1000) / baudrate);\n    ndelay(60);\n    rs485_dtr_set(rs485_worker-&gt;tty-&gt;index, false);\n    kfree(rs485_worker);\n}\n\nstatic void hook_uart_write_onreturn(struct kprobe* p, struct pt_regs* regs, unsigned long flags) {\n    struct tty_struct* tty = (struct tty_struct*)regs-&gt;regs[0];\n    if (rs485_is_builtin_dev(tty)) {\n        int dev_num = rs485_get_dev_num(tty);\n        if (dev_num != -EINVAL) {\n            struct rs485_worker_t* rs485_worker = kmalloc(sizeof(*rs485_worker), GFP_KERNEL);\n            rs485_worker-&gt;tty = tty;\n            if (rs485_worker) {\n                INIT_DELAYED_WORK(&amp;rs485_worker-&gt;work, rs485_worker_oncomplete);\n                int queue_index = rs485_get_worker_index(dev_num);\n                if (queue_index != -EINVAL) {\n                    queue_delayed_work(rs485_worker_queues[queue_index], &amp;rs485_worker-&gt;work, 0);\n                }\n            }\n        }\n    }\n}\n\nstatic int hook_uart_write_onstart(struct kprobe* p, struct pt_regs* regs) {\n    struct tty_struct* tty = (struct tty_struct*)regs-&gt;regs[0];\n    if (rs485_is_builtin_dev(tty)) {\n        int dev_num = rs485_get_dev_num(tty);\n        rs485_dtr_set(dev_num, true);\n    }\n\n    return 0;\n}\n\nstatic unsigned long get_fn_addr(const char* symbol_name) {\n    struct kprobe temp_kp = {.symbol_name = symbol_name};\n    int ret = register_kprobe(&amp;temp_kp);\n    unsigned long fn_addr = (unsigned long)temp_kp.addr;\n\n    unregister_kprobe(&amp;temp_kp);\n    if (ret &lt; 0) {\n        return ret;\n    }\n    if (temp_kp.addr == NULL) {\n        return -EFAULT;\n    }\n\n    return fn_addr;\n}\n\n#define LOG_PREFIX MODULE_NAME \": \"\nstruct kprobe hook_uart_write;\n\nstatic int module_init_fn(void) {\n    rs485_dtr_init();\n\n    // Create worker queues for each RS-485 interface\n    rs485_worker_queues[0] = create_singlethread_workqueue(MODULE_NAME \"_worker_queue_2\");\n    if (rs485_worker_queues[0] == NULL) {\n        printk(KERN_ERR LOG_PREFIX \"Failed to create worker queue for ttyAMA2\\n\");\n        return -ENOMEM;\n    }\n    rs485_worker_queues[1] = create_singlethread_workqueue(MODULE_NAME \"_worker_queue_3\");\n    if (rs485_worker_queues[1] == NULL) {\n        printk(KERN_ERR LOG_PREFIX \"Failed to create worker queue for ttyAMA3\\n\");\n        return -ENOMEM;\n    }\n    rs485_worker_queues[2] = create_singlethread_workqueue(MODULE_NAME \"_worker_queue_5\");\n    if (rs485_worker_queues[2] == NULL) {\n        printk(KERN_ERR LOG_PREFIX \"Failed to create worker queue for ttyAMA5\\n\");\n        return -ENOMEM;\n    }\n\n    // Hook `uart_write` function\n    unsigned long target_fn_addr = get_fn_addr(\"uart_write\");\n    if (target_fn_addr &lt; 0) {\n        printk(KERN_ERR LOG_PREFIX \"Failed to get address for `uart_write`, returned code: %ld\\n\", target_fn_addr);\n        return target_fn_addr;\n    }\n    hook_uart_write.addr = (kprobe_opcode_t*)target_fn_addr;\n    hook_uart_write.pre_handler = (void*)hook_uart_write_onstart;\n    hook_uart_write.post_handler = (void*)hook_uart_write_onreturn;\n    int ret = register_kprobe(&amp;hook_uart_write);\n    if (ret &lt; 0) {\n        printk(KERN_ERR LOG_PREFIX \"Failed to register kprobe for `uart_write`, returned code: %d\\n\", ret);\n        return ret;\n    }\n\n    printk(KERN_INFO LOG_PREFIX \"RS-485 interface has been hooked successfully\\n\");\n    return 0;\n}\n\nstatic void module_exit_fn(void) {\n    unregister_kprobe(&amp;hook_uart_write);\n    for (int i = 0; i &lt; sizeof(rs485_worker_queues) / sizeof(rs485_worker_queues[0]); i++) {\n        if (rs485_worker_queues[i]) {\n            destroy_workqueue(rs485_worker_queues[i]);\n        }\n    }\n    rs485_dtr_deinit();\n\n    printk(KERN_INFO LOG_PREFIX \"RS-485 interface has been unhooked successfully\\n\");\n}\n\nmodule_init(module_init_fn);\nmodule_exit(module_exit_fn);\n</code></pre>\n<h2 id=\"theresultandthoughts\">The Result and Thoughts</h2>\n<p><img src=\"https://assets.n0w0n.com/the_60000_usd_patch_is_a_triumph/4.gif\" alt=\"The Kernel Module Solution\" /></p>\n<p>After deploying the module and testing extensively across various baud rates, the issue was successfully resolved. There was no need to replace products or recall shipments, saving the company $60,000 and sparing customers from potential inconvenience. Well, the software-level solution proved efficient, effective, and sustainable.</p>\n<p>This experience reaffirmed the importance of thinking creatively when addressing challenges. Even as a newcomer, I was able to leverage open-source tools and innovative thinking to tackle a seemingly insurmountable problem. It’s a reminder that in technology, persistence and curiosity often yield unexpected and rewarding outcomes.</p>",
            "url": "https://n0w0n.com/post/the_60000_usd_patch_is_a_triumph",
            "title": "The $60,000 Patch: A Newcomer's One-Week Triumph",
            "summary": "<p>In mid-October, after three rounds of assessments and interviews, I finally get a work from a company that specializing in open-source IoT and embedded development.</p>\n<p>As an application engineer at this company, my responsibilities include building libraries, maintaining product documentation on the wiki, and creating customized demos for various edge computing devices. Just a few days into the role, I learned about a legacy issue with one of the products. Specifically, the RS485 interfaces had a critical flaw that prevented the port from properly switching the data direction.</p>\n<p>The R&amp;D team had previously attempted to address this issue at the application layer by developing a utility tool called <code>rs485_DE</code> using C. This tool would open the original RS485 port (e.g., <code>/dev/ttyAMA2</code>), then create a new virtual serial port, and monitor data on the virtual port. It would then automatically toggle the chip's $\\overline{\\text{RE}}$ pin based on the data flow direction. However, this approach introduced a new issue: the higher baud rates, the more frequently data loss would occurr. The root cause was the tool's reliance on polling to check the buffers, coupled with the use of the <code>libgpiod</code> library to manipulate GPIOs for flow control, which was too slow to meet the performance requirements.</p>\n<p>Adding to the complexity, the RS485 transceiver chip used in the product was the TPT7487. On this chip, the $\\overline{\\text{RE}}$ pin is responsible for controlling the chip's mode - either receive or transmit. However, instead of being connected to dedicated DTR pins, the $\\overline{\\text{RE}}$ pin was wired to several general-purpose GPIO pins on the Compute Module 4 (CM4). Unfortunately, the kernel driver did not configure these GPIOs as DTR pins, further limiting the ability to implement a hardware-based solution for automatic data direction control.</p>\n<p><img src=\"https://assets.n0w0n.com/the_60000_usd_patch_is_a_triumph/1.png\" alt=\"The general-purpose GPIO pins to RS485 transceiver chips\" />\n<img src=\"https://assets.n0w0n.com/the_60000_usd_patch_is_a_triumph/2.png\" alt=\"The RS485 transceiver schematic\" /></p>\n<p>After thorough discussions and evaluations, the team concluded that replacing all affected products was the only viable solution. Despite the significant cost - an estimated $60,000 - the company prioritized customer satisfaction and product reliability. With no better technical solution available, the recall decision was made to uphold the company's reputation and ensure long-term trust from customers.</p>\n<p>Out of curiosity, I requested the schematic of the product and, after some analysis, I surprisingly discovered what I believed could be a potential software solution to the issues. That marked the beginning of a new chapter in addressing the problem.</p>",
            "date_modified": "2025-01-21T01:31:22.000Z"
        },
        {
            "id": "allwinner_h3_memory_mapping",
            "content_html": "<p>When it comes to control the GPIO pins on a development board, many of developers have tried to access the GPIO pins from the user space (e.g. The <code>sysfs</code>). But this approach may not perform well because it's not that fast as you may thought - at least it was vividly reflected in one of my recent needs.</p>\n<p>Recently I took over a maker-level project that uses the Raspberry Pi and in the project, the Pi needs to continuously poll the level of a certain output from the FPGA at high speed to determine whether the data is \"ready\". However, as the price of Raspberry Pi rises, I had to consider the affordable alternative, finally I settled on the Orange Pi One, which uses the Allwinner H3 and has a 512 MB of RAM - That's enough for my needs.</p>\n<p>In the original Raspberry Pi implementation for the project, the state of the GPIO pins was obtained directly by accessing the GPIO registers - the memory mapping (mmap), and we know that different SOCs have different internal register sets and addresses, so to port the project to the Allwinner H3, some significant changes in the code were required.</p>\n<p>This article will introduce how I understand the concept of mmap, and how did I analyse the datasheet provided by Allwinner, in the last, I'll provide a complete example of how to use mmap to access GPIO pins in C, Go, and Python.</p>\n<p><img src=\"https://assets.n0w0n.com/allwinner_h3_memory_mapping/1.jpg\" alt=\"Orange Pi One\" /></p>\n<h2 id=\"theconceptofmmap\">The Concept of MMAP</h2>\n<p>In simple terms, mmap allows a physical memory region to be mapped to the application's virtual memory space. This enables direct manipulation of CPU registers at the application level.</p>\n<p>In conventional development, we typically use the Linux generic sysfs interface to control GPIOs. Through this interface, GPIOs can be configured to output specific signal levels or read external signals input to the GPIO. However, this method is only suitable for scenarios where speed requirements are not stringent. When high-speed GPIO access is required, the sysfs method becomes inefficient. This is because sysfs relies on file I/O operations for GPIO control. Each operation involves accessing the file system and making system calls, which introduces performance overhead.</p>\n<p>To eliminate this additional performance cost and break through the file I/O bottleneck, an alternative approach is to bypass these layers. The mmap method allows direct operations on GPIOs in physical memory, theoretically achieving faster GPIO access.</p>\n<h2 id=\"theprincipleofcontrolling\">The Principle of Controlling</h2>\n<p>It is known that the GPIOs on a development board are essentially part of the CPU pins. Since these pins can be controlled programmatically, there must be corresponding registers within the CPU. These registers are mapped to specific physical address ranges that remain constant. By using mmap to operate on the CPU's internal registers, it becomes possible to control specific GPIOs in this manner.</p>\n<p>To control GPIOs via mmap, the process involves the following 5 steps:</p>\n<ol>\n<li>Open the <code>/dev/mem</code> device file.</li>\n<li>Determine the physical address of the GPIO control registers.</li>\n<li>Use mmap to map the physical address to user space.</li>\n<li>Access the GPIO control registers.</li>\n<li>Unmap the mmap region.</li>\n</ol>\n<p>Among these steps, step 2 requires consulting the CPU vendor's datasheet to identify the relevant details.</p>\n<h2 id=\"consultingthedatasheet\">Consulting the Datasheet</h2>\n<p><a href=\"https://dl.linux-sunxi.org/H3/Allwinner_H3_Datasheet_V1.0.pdf\">The datasheet</a>, provided by Allwinner is an extensive 618 pages, making it impractical to read in full. Instead, relevant sections can be found by using Ctrl + F to search for the following keywords:</p>\n<ul>\n<li>Base Address: Identifies the base address.</li>\n<li>Register: Provides details on the registers.</li>\n</ul>\n<p>And the key findings from the datasheet are given as follows:</p>\n<ul>\n<li>CPU Base Address: On page 90, section 4.3.4, Register List, it is mentioned that the base address for all CPU registers is <code>0x01C20000</code>.</li>\n<li>GPIO Base Address: On page 318, section 4.22.1, Port Controller Register List, it is noted that the GPIO base address is <code>0x01C20800</code>.</li>\n<li>The offset between the CPU base address and the GPIO base address is therefore <code>0x0800</code>.</li>\n</ul>\n<p>on page 318, section 4.22.2, at Port Controller Register, the GPIO register configurations are detailed. After excluding interrupt-related registers, the useful registers for GPIO configuration are as follows:</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left;\">Register</th>\n<th style=\"text-align:left;\">Offset</th>\n<th style=\"text-align:left;\">Description</th>\n<th style=\"text-align:left;\">Remarks</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left;\">Pn_CFG0</td>\n<td style=\"text-align:left;\">n*0x24 + 0x00</td>\n<td style=\"text-align:left;\">GPIO_n configuration register 0 for setting up pin mode</td>\n<td style=\"text-align:left;\">First determine the port number (e.g. GPIO_A) and pin number (e.g. 6) for which you want to set the GPIO mode.</td>\n</tr>\n<tr>\n<td style=\"text-align:left;\">Pn_CFG1</td>\n<td style=\"text-align:left;\">n*0x24 + 0x04</td>\n<td style=\"text-align:left;\">GPIO_n configuration register 1 for setting up pin mode</td>\n<td style=\"text-align:left;\">Then in the P<u>n</u> Configure Register <u>x</u> table following this table in the Datasheet, where n = [0…6] and x = [0…3],</td>\n</tr>\n<tr>\n<td style=\"text-align:left;\">Pn_CFG2</td>\n<td style=\"text-align:left;\">n*0x24 + 0x08</td>\n<td style=\"text-align:left;\">GPIO_n configuration register 2 for setting up pin mode</td>\n<td style=\"text-align:left;\">find the corresponding \"bit\" and \"value\" for the GPIO mode you want to set.</td>\n</tr>\n<tr>\n<td style=\"text-align:left;\">Pn_CFG3</td>\n<td style=\"text-align:left;\">n*0x24 + 0x0C</td>\n<td style=\"text-align:left;\">GPIO_n configuration register 3 for setting up pin mode</td>\n<td style=\"text-align:left;\">(The code n mentioned above also refers to one of the GPIO port numbers A, C, D, E, F, G, L)</td>\n</tr>\n<tr>\n<td style=\"text-align:left;\">Pn_DAT</td>\n<td style=\"text-align:left;\">n*0x24 + 0x10</td>\n<td style=\"text-align:left;\">GPIO_n data register for accessing the state of GPIO pin</td>\n<td style=\"text-align:left;\">In input mode, the corresponding bit indicates the pin status; in output mode, the pin status is the same as the corresponding bit</td>\n</tr>\n<tr>\n<td style=\"text-align:left;\">Pn_DRV0</td>\n<td style=\"text-align:left;\">n*0x24 + 0x14</td>\n<td style=\"text-align:left;\">GPIO_n drive capability register 0, used to configure the output drive capability of GPIO n</td>\n<td style=\"text-align:left;\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left;\">Pn_DRV1</td>\n<td style=\"text-align:left;\">n*0x24 + 0x18</td>\n<td style=\"text-align:left;\">GPIO_n drive capability register 1, used to configure the output drive capability of GPIO n</td>\n<td style=\"text-align:left;\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left;\">Pn_PUL0</td>\n<td style=\"text-align:left;\">n*0x24 + 0x1C</td>\n<td style=\"text-align:left;\">GPIO_n Pull-up / Pull-down register 0, used to configure the pull-up / pull-down of GPIO n</td>\n<td style=\"text-align:left;\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left;\">Pn_PUL1</td>\n<td style=\"text-align:left;\">n*0x24 + 0x20</td>\n<td style=\"text-align:left;\">GPIO_n Pull-up / Pull-down register 1, used to configure the pull-up / pull-down of GPIO n</td>\n<td style=\"text-align:left;\"></td>\n</tr>\n</tbody>\n</table>\n<p>Although we know the GPIO register base address is <code>0x01C20800</code>, specific ports like GPIO_A require knowledge of their offset from the GPIO base address.</p>\n<p>From page 319 of the datasheet, section 4.22.2.1 (PA Configure Register 0), we learn: GPIO<em>A registers start at an offset of 0x00 relative to the GPIO base address, the configuration for GPIO</em>A registers ends at <code>0x01C20820</code>, with a total width of 0x20 bytes.</p>\n<p>Given this layout, the following C structure can represent the GPIO register set:</p>\n<pre><code class=\"cpp language-cpp\">typedef struct {\n    volatile uint32_t config[4];\n    volatile uint32_t data;\n    volatile uint32_t driver[2];\n    volatile uint32_t pull[2];\n} gpio_t;\n</code></pre>\n<p>In this structure, the keyword <code>volatile</code> tells the compiler that the member variables of this structure may be modified by other threads or interrupts, so the compiler should not optimize this structure.</p>\n<h2 id=\"someexamples\">Some Examples</h2>\n<h3 id=\"example1configuregpio_a20asanoutputandsethigh\">Example 1: Configure GPIO_A20 as an Output and Set High</h3>\n<p>To configure GPIO_A20 as an output and drive it high, refer to the following details from the datasheet:</p>\n<ol>\n<li>GPIO<em>A20's configuration is located in the PA</em>CFG2_REG register (bits 20–22). Set its value to <code>0x01</code> to configure it as an output.</li>\n<li>To output a high signal, set bit 20 in the PA<em>DATA</em>REG register to <code>0x01</code>.</li>\n</ol>\n<h3 id=\"example2configuregpio_a8asaninputwithpullupenabled\">Example 2: Configure GPIO_A8 as an Input with Pull-Up Enabled</h3>\n<p>To configure GPIO_A8 as an input and enable the pull-up resistor, refer to the following details from the datasheet:</p>\n<ol>\n<li>GPIO<em>A8's configuration is located in the PA</em>CFG1_REG register (bits 0–2). Set its value to <code>0x00</code> to configure it as an input.</li>\n<li>To enable the pull-up resistor, set bits 16–17 in the PA<em>PULL0</em>REG register to <code>0x01</code>.</li>\n</ol>\n<h2 id=\"practicaldemonstration\">Practical Demonstration</h2>\n<p>With the foundational knowledge covered, we can now write programs to solve the problem.</p>\n<p>These examples demonstrates how to use C, Go, and Python to control GPIO<em>A21 to toggle an LED and read the level of GPIO</em>A8. The level of GPIO_A8 is printed to the terminal.</p>\n<p>Note: Since GPIO_A8 has pull-up enabled, its default level is high unless the pin is grounded. Similarly, if pull-down is enabled, the default level will be low unless connected to power supply.</p>\n<h3 id=\"thecimplementation\">The C Implementation</h3>\n<p>Here is the C version, where the <code>gpio_t</code> structure is the same as defined earlier. The <code>set_output</code> function configures the GPIO pin as output mode, the <code>set_input</code> function configures the GPIO pin as input mode, the <code>set_level</code> function sets the GPIO pin level, and the <code>get_level</code> function reads the GPIO pin level.</p>\n<pre><code class=\"cpp language-cpp\">#include &lt;fcntl.h&gt;\n#include &lt;stdint.h&gt;\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;sys/mman.h&gt;\n#include &lt;unistd.h&gt;\n\n// GPIO_A configuration register list\n// { Register number, Register bit }\nconst int GPIO_A_CONFIG[22][2] = {\n    {0, 0},   // PA0\n    {0, 4},   // PA1\n    {0, 8},   // PA2\n    {0, 12},  // PA3\n    {0, 16},  // PA4\n    {0, 20},  // PA5\n    {0, 24},  // PA6\n    {0, 28},  // PA7\n\n    {1, 0},   // PA8\n    {1, 4},   // PA9\n    {1, 8},   // PA10\n    {1, 12},  // PA11\n    {1, 16},  // PA12\n    {1, 20},  // PA13\n    {1, 24},  // PA14\n    {1, 28},  // PA15\n\n    {2, 0},   // PA16\n    {2, 4},   // PA17\n    {2, 8},   // PA18\n    {2, 12},  // PA19\n    {2, 16},  // PA20\n    {2, 20},  // PA21\n};\n\n// Base address of registers\n#define ALLWINNER_H3_BASE 0x01C20000\n// Offset of GPIO_A relative to ALLWINNER_H3_BASE\n#define GPIO_PA_OFFSET 0x0800\n// Size of the memory region to be mapped using mmap\n#define MMAP_SIZE 0x1000\n\n// GPIO mode configuration\nenum GPIO_MODE {\n    INPUT = 0,\n    OUTPUT,\n};\n// GPIO level configuration\nenum GPIO_LEVEL {\n    LOW = 0,\n    HIGH,\n};\n// GPIO pull-up/pull-down configuration\nenum GPIO_PULL {\n    PULL_OFF = 0,\n    PULL_UP,\n    PULL_DOWN,\n};\n\n// GPIO port register type\ntypedef struct {\n    volatile uint32_t config[4];\n    volatile uint32_t data;\n    volatile uint32_t driver[2];\n    volatile uint32_t pull[2];\n} gpio_t;\n\n// Configure the specified pin of GPIO_A as output\nvoid set_output(gpio_t* gpio, int pin) {\n    // Get the register number and register bit\n    int reg = GPIO_A_CONFIG[pin][0];\n    int bit = GPIO_A_CONFIG[pin][1];\n    // Clear the previous configuration\n    gpio-&gt;config[reg] &amp;= ~(0x0F &lt;&lt; bit);\n    // Set as output mode\n    gpio-&gt;config[reg] |= (OUTPUT &lt;&lt; bit);\n}\n\n// Configure the specified pin of GPIO_A as input\nvoid set_input(gpio_t* gpio, int pin) {\n    // Get the register number and register bit\n    int reg = GPIO_A_CONFIG[pin][0];\n    int bit = GPIO_A_CONFIG[pin][1];\n    // Clear the previous configuration\n    gpio-&gt;config[reg] &amp;= ~(0x0F &lt;&lt; bit);\n    // Set as input mode\n    gpio-&gt;config[reg] |= (INPUT &lt;&lt; bit);\n}\n\n// Configure pull-up/pull-down for the specified pin of GPIO_A\nvoid set_pull(gpio_t* gpio, int pin, int pull) {\n    // Get the register number\n    int reg = pin / 16;\n    // Get the register bit\n    int bit = (pin % 16) * 2;\n    // Clear the previous configuration\n    gpio-&gt;pull[reg] &amp;= ~(0x03 &lt;&lt; bit);\n    // Set pull-up/pull-down configuration\n    gpio-&gt;pull[reg] |= (uint32_t)pull &lt;&lt; bit;\n}\n\n// Set the level of the specified pin of GPIO_A\nvoid set_level(gpio_t* gpio, int pin, int level) {\n    switch (level) {\n        case HIGH:\n            gpio-&gt;data |= (1 &lt;&lt; pin);\n            return;\n        case LOW:\n            gpio-&gt;data &amp;= ~(1 &lt;&lt; pin);\n            return;\n        defaults:\n            return;\n    }\n}\n\n// Read the level of the specified pin of GPIO_A\nint get_level(gpio_t* gpio, int pin) {\n    // Get the register number and register bit\n    int reg = GPIO_A_CONFIG[pin][0];\n    int bit = GPIO_A_CONFIG[pin][1];\n    // Clear the previous configuration\n    gpio-&gt;config[reg] &amp;= ~(0x0F &lt;&lt; bit);\n    return (gpio-&gt;data &gt;&gt; pin) &amp; 0x01;\n}\n\nint main() {\n    // Open /dev/mem device file in read-write mode\n    int mem = open(\"/dev/mem\", O_RDWR | O_SYNC);\n    if (mem &lt; 0) {\n        perror(\"open /dev/mem\");\n        return -1;\n    }\n\n    // Map the register into memory\n    char* reg = (char*)mmap(NULL, MMAP_SIZE, PROT_READ | PROT_WRITE, MAP_SHARED,\n                            mem, ALLWINNER_H3_BASE);\n    if (reg == MAP_FAILED) {\n        perror(\"mmap\");\n        close(mem);\n        return -1;\n    }\n\n    // Apply the offset to the GPIO_A register type\n    gpio_t* gpio = (gpio_t*)&amp;reg[GPIO_PA_OFFSET];\n\n    // Set GPIO_A21 as output\n    set_output(gpio, 21);\n    // Set GPIO_A8 as input\n    set_input(gpio, 8);\n    // Enable pull-up for GPIO_A8\n    set_pull(gpio, 8, PULL_UP);\n\n    // Blink the LED and read the level\n    for (;;) {\n        // Toggle GPIO_A21 LED\n        set_level(gpio, 21, HIGH);\n        usleep(500000);\n        set_level(gpio, 21, LOW);\n        usleep(500000);\n        // Read and print the level of GPIO_A8\n        int level = get_level(gpio, 8);\n        printf(\"GPIO_A8 level: %d\\n\", level);\n    }\n\n    // Unmap the memory\n    munmap(gpio, MMAP_SIZE);\n    close(mem);\n\n    return 0;\n}\n</code></pre>\n<h3 id=\"thegoimplementation\">The Go Implementation</h3>\n<p>Here is the Go language implementation. In this version, memory mapping is performed using the <code>syscall.Mmap()</code> and <code>syscall.Munmap()</code> functions.</p>\n<p>Additionally, unlike the C version where pointer casting is done with (gpio_t *) and dereferencing operators *, the Go version uses the <code>unsafe.Pointer</code> type and the <code>unsafe.Pointer()</code> function for pointer conversion, allowing direct memory address manipulation.</p>\n<pre><code class=\"go language-go\">package main\n\nimport (\n    \"fmt\"\n    \"os\"\n    \"syscall\"\n    \"time\"\n    \"unsafe\"\n)\n\n// GPIO_A configuration register list\n// { register number, register bit }\nvar GPIO_A_CONFIG = [22][2]int{\n    {0, 0},  // PA0\n    {0, 4},  // PA1\n    {0, 8},  // PA2\n    {0, 12}, // PA3\n    {0, 16}, // PA4\n    {0, 20}, // PA5\n    {0, 24}, // PA6\n    {0, 28}, // PA7\n\n    {1, 0},  // PA8\n    {1, 4},  // PA9\n    {1, 8},  // PA10\n    {1, 12}, // PA11\n    {1, 16}, // PA12\n    {1, 20}, // PA13\n    {1, 24}, // PA14\n    {1, 28}, // PA15\n\n    {2, 0},  // PA16\n    {2, 4},  // PA17\n    {2, 8},  // PA18\n    {2, 12}, // PA19\n    {2, 16}, // PA20\n    {2, 20}, // PA21\n}\n\nconst (\n    // Base address of registers\n    ALLWINNER_H3_BASE = 0x01C20000\n    // Offset of GPIO_A relative to ALLWINNER_H3_BASE\n    GPIO_PA_OFFSET = 0x0800\n    // Size of the region to be mapped when using the mmap function\n    MMAP_SIZE = 0x1000\n)\n\n// GPIO mode configuration\nconst (\n    INPUT  = 0\n    OUTPUT = 1\n)\n\n// GPIO level configuration\nconst (\n    LOW  = 0\n    HIGH = 1\n)\n\n// Pull-up/down configuration\nconst (\n    PULL_OFF  = 0\n    PULL_UP   = 1\n    PULL_DOWN = 2\n)\n\n// GPIO port register type\ntype gpio_t struct {\n    config [4]uint32\n    data   uint32\n    driver [2]uint32\n    pull   [2]uint32\n}\n\nfunc setOutput(gpio *gpio_t, pin int) {\n    // Get the register number and register bit\n    reg := GPIO_A_CONFIG[pin][0]\n    bit := GPIO_A_CONFIG[pin][1]\n    // Clear the original configuration\n    gpio.config[reg] &amp;= ^(0x0F &lt;&lt; bit)\n    // Set to output mode\n    gpio.config[reg] |= OUTPUT &lt;&lt; bit\n}\n\nfunc setInput(gpio *gpio_t, pin int) {\n    // Get the register number and register bit\n    reg := GPIO_A_CONFIG[pin][0]\n    bit := GPIO_A_CONFIG[pin][1]\n    // Clear the original configuration\n    gpio.config[reg] &amp;= ^(0x0F &lt;&lt; bit)\n    // Set to input mode\n    gpio.config[reg] |= INPUT &lt;&lt; bit\n}\n\nfunc setPull(gpio *gpio_t, pin, pull int) {\n    // Get the register number\n    reg := pin / 16\n    // Get the register bit\n    bit := (pin % 16) * 2\n    // Clear the original configuration\n    gpio.pull[reg] &amp;= ^(0x03 &lt;&lt; bit)\n    // Set pull-up/down\n    gpio.pull[reg] |= uint32(pull) &lt;&lt; bit\n}\n\nfunc setLevel(gpio *gpio_t, pin, level int) {\n    switch level {\n    case HIGH:\n        gpio.data |= 1 &lt;&lt; pin\n    case LOW:\n        gpio.data &amp;= ^(1 &lt;&lt; pin)\n    }\n}\n\nfunc getLevel(gpio *gpio_t, pin int) int {\n    // Get the register number and register bit\n    reg := GPIO_A_CONFIG[pin][0]\n    bit := GPIO_A_CONFIG[pin][1]\n    // Clear the original configuration\n    gpio.config[reg] &amp;= ^(0x0F &lt;&lt; bit)\n    return int((gpio.data &gt;&gt; pin) &amp; 0x01)\n}\n\nfunc main() {\n    // Open /dev/mem device file in read-write mode\n    mem, err := os.OpenFile(\"/dev/mem\", os.O_RDWR|os.O_SYNC, 0)\n    if err != nil {\n        fmt.Printf(\"Failed to open /dev/mem: %v\\n\", err)\n        return\n    }\n    defer mem.Close()\n\n    // Map the registers to memory\n    reg, err := syscall.Mmap(int(mem.Fd()), ALLWINNER_H3_BASE, MMAP_SIZE, syscall.PROT_READ|syscall.PROT_WRITE, syscall.MAP_SHARED)\n    if err != nil {\n        fmt.Printf(\"Failed to mmap: %v\\n\", err)\n        return\n    }\n    defer syscall.Munmap(reg)\n\n    // Apply the mapped address offset to the GPIO_A register type\n    gpio := (*gpio_t)(unsafe.Pointer(&amp;reg[GPIO_PA_OFFSET]))\n\n    // Set GPIO_A21 as output mode\n    setOutput(gpio, 21)\n    // Set GPIO_A8 as input mode\n    setInput(gpio, 8)\n    // Enable pull-up for GPIO_A8\n    setPull(gpio, 8, PULL_UP)\n\n    // Blink the LED and read the level\n    for {\n        // Blink the GPIO_A21 LED\n        setLevel(gpio, 21, HIGH)\n        time.Sleep(time.Millisecond * 500)\n        setLevel(gpio, 21, LOW)\n        time.Sleep(time.Millisecond * 500)\n        // Read and print the level of GPIO_A8\n        level := getLevel(gpio, 8)\n        fmt.Printf(\"GPIO_A8 level: %d\\n\", level)\n    }\n}\n</code></pre>\n<h3 id=\"thepythonimplementation\">The Python Implementation</h3>\n<p>The Python implementation is similar to the Go implementation, using the <code>mmap</code> library to perform memory mapping and unmapping.</p>\n<pre><code class=\"python language-python\">from mmap import mmap, MAP_SHARED, PROT_READ, PROT_WRITE\nfrom os import open, close, O_RDWR, O_SYNC\nfrom ctypes import Structure, c_uint32\nfrom typing import Type\nfrom time import sleep\nfrom sys import exit\n\n# GPIO_A configuration register list\n# { register number, register bit }\nGPIO_A_CONFIG = [\n    [0, 0],  # PA0\n    [0, 4],  # PA1\n    [0, 8],  # PA2\n    [0, 12],  # PA3\n    [0, 16],  # PA4\n    [0, 20],  # PA5\n    [0, 24],  # PA6\n    [0, 28],  # PA7\n    [1, 0],  # PA8\n    [1, 4],  # PA9\n    [1, 8],  # PA10\n    [1, 12],  # PA11\n    [1, 16],  # PA12\n    [1, 20],  # PA13\n    [1, 24],  # PA14\n    [1, 28],  # PA15\n    [2, 0],  # PA16\n    [2, 4],  # PA17\n    [2, 8],  # PA18\n    [2, 12],  # PA19\n    [2, 16],  # PA20\n    [2, 20],  # PA21\n]\n\n# Base address of the registers\nALLWINNER_H3_BASE = 0x01C20000\n# Offset of GPIO_A relative to ALLWINNER_H3_BASE\nGPIO_PA_OFFSET = 0x0800\n# Size of the region to be mapped when using the mmap function\nMMAP_SIZE = 0x1000\n# GPIO mode configuration\nINPUT = 0\nOUTPUT = 1\n# GPIO level configuration\nLOW = 0\nHIGH = 1\n# Pull-up/down configuration\nPULL_OFF = 0\nPULL_UP = 1\nPULL_DOWN = 2\n\n\n# GPIO port register type\nclass gpio_t(Structure):\n    _fields_ = [\n        (\"config\", c_uint32 * 4),\n        (\"data\", c_uint32),\n        (\"driver\", c_uint32 * 2),\n        (\"pull\", c_uint32 * 2),\n    ]\n\n\n# Configure the specified GPIO_A pin as output mode\ndef set_output(gpio: Type[gpio_t], pin: int) -&gt; None:\n    # Get the register number and register bit\n    reg, bit = GPIO_A_CONFIG[pin]\n    # Clear the original configuration\n    gpio.config[reg] &amp;= ~(0x0F &lt;&lt; bit)\n    # Set as output mode\n    gpio.config[reg] |= (OUTPUT &lt;&lt; bit)\n\n\n# Configure the specified GPIO_A pin as input mode\ndef set_input(gpio: Type[gpio_t], pin: int) -&gt; None:\n    # Get the register number and register bit\n    reg, bit = GPIO_A_CONFIG[pin]\n    # Clear the original configuration\n    gpio.config[reg] &amp;= ~(0x0F &lt;&lt; bit)\n    # Set as input mode\n    gpio.config[reg] |= (INPUT &lt;&lt; bit)\n\n\n# Configure pull-up/down for the specified GPIO_A pin\ndef set_pull(gpio: Type[gpio_t], pin: int, pull: int) -&gt; None:\n    # Get the register number\n    reg = int(pin / 16)\n    # Get the register bit\n    bit = int((pin % 16) * 2)\n    # Clear the original configuration\n    gpio.pull[reg] &amp;= ~(0x03 &lt;&lt; bit)\n    # Set pull-up/down\n    gpio.pull[reg] |= (pull &lt;&lt; bit)\n\n\n# Set the level of the specified GPIO_A pin\ndef set_level(gpio: Type[gpio_t], pin: int, level: int) -&gt; None:\n    if level == HIGH:\n        gpio.data |= (1 &lt;&lt; pin)\n    elif level == LOW:\n        gpio.data &amp;= ~(1 &lt;&lt; pin)\n\n\n# Read the level of the specified GPIO_A pin\ndef get_level(gpio: Type[gpio_t], pin: int) -&gt; int:\n    # Get the register number and register bit\n    reg, bit = GPIO_A_CONFIG[pin]\n    # Clear the original configuration\n    gpio.config[reg] &amp;= ~(0x0F &lt;&lt; bit)\n    return (gpio.data &gt;&gt; pin) &amp; 0x01\n\n\ndef main():\n    # Open the /dev/mem device file in read-write mode\n    mem = open(\"/dev/mem\", O_RDWR | O_SYNC)\n    if mem &lt; 0:\n        print(\"Failed to open /dev/mem\")\n        exit(1)\n\n    # Map the registers to memory\n    reg = mmap(\n        mem, MMAP_SIZE, MAP_SHARED,\n        PROT_READ | PROT_WRITE,\n        offset=ALLWINNER_H3_BASE\n    )\n\n    # Apply the mapped address offset to the GPIO_A register type\n    gpio = gpio_t.from_buffer(reg, GPIO_PA_OFFSET)\n\n    # Set GPIO_A21 as output mode\n    set_output(gpio, 21)\n    # Set GPIO_A8 as input mode\n    set_input(gpio, 8)\n    # Enable pull-up for GPIO_A8\n    set_pull(gpio, 8, PULL_UP)\n\n    # Blink the LED and read the level\n    while True:\n        # Blink the GPIO_A21 LED\n        set_level(gpio, 21, HIGH)\n        sleep(0.5)\n        set_level(gpio, 21, LOW)\n        sleep(0.5)\n        # Read and print the level of GPIO_A8\n        level = get_level(gpio, 8)\n        print(\"GPIO_A8 level:\", level)\n\n    # Unmap the memory\n    reg.close()\n    close(mem)\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>\n<h2 id=\"theconclusion\">The Conclusion</h2>\n<p>Last but not least, we have successfully implemented the memory mapping in the Allwinner H3 platform. It works like magic now!</p>\n<p><img src=\"https://assets.n0w0n.com/allwinner_h3_memory_mapping/2.gif\" alt=\"GPIO_A21 Blinking LED\" />\n<img src=\"https://assets.n0w0n.com/allwinner_h3_memory_mapping/3.png\" alt=\"Read GPIO_A8 Level\" /></p>",
            "url": "https://n0w0n.com/post/allwinner_h3_memory_mapping",
            "title": "MMAP on Allwinner H3 - The Faster Way to Access to GPIO Pins",
            "summary": "<p>When it comes to control the GPIO pins on a development board, many of developers have tried to access the GPIO pins from the user space (e.g. The <code>sysfs</code>). But this approach may not perform well because it's not that fast as you may thought - at least it was vividly reflected in one of my recent needs.</p>\n<p>Recently I took over a maker-level project that uses the Raspberry Pi and in the project, the Pi needs to continuously poll the level of a certain output from the FPGA at high speed to determine whether the data is \"ready\". However, as the price of Raspberry Pi rises, I had to consider the affordable alternative, finally I settled on the Orange Pi One, which uses the Allwinner H3 and has a 512 MB of RAM - That's enough for my needs.</p>\n<p>In the original Raspberry Pi implementation for the project, the state of the GPIO pins was obtained directly by accessing the GPIO registers - the memory mapping (mmap), and we know that different SOCs have different internal register sets and addresses, so to port the project to the Allwinner H3, some significant changes in the code were required.</p>\n<p>This article will introduce how I understand the concept of mmap, and how did I analyse the datasheet provided by Allwinner, in the last, I'll provide a complete example of how to use mmap to access GPIO pins in C, Go, and Python.</p>\n<p><img src=\"https://assets.n0w0n.com/allwinner_h3_memory_mapping/1.jpg\" alt=\"Orange Pi One\" /></p>",
            "date_modified": "2023-05-20T05:08:00.000Z"
        }
    ]
}