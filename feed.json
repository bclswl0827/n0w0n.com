{
    "version": "https://jsonfeed.org/version/1",
    "title": "The [object Object]",
    "home_page_url": "httpsn0w0n.com/",
    "feed_url": "https://n0w0n.com/feed.json",
    "icon": "/avatar.jpg",
    "author": {
        "name": "Unknown netizen"
    },
    "items": [
        {
            "id": "the_60000_usd_patch_is_a_triumph",
            "content_html": "\nIn mid-October, after three rounds of assessments and interviews, I finally get a work from a company that specializing in open-source IoT and embedded development.\n\nAs an application engineer at this company, my responsibilities include building libraries, maintaining product documentation on the wiki, and creating customized demos for various edge computing devices. Just a few days into the role, I learned about a legacy issue with one of the products. Specifically, the RS485 interfaces had a critical flaw that prevented the port from properly switching the data direction.\n\nThe R&D team had previously attempted to address this issue at the application layer by developing a utility tool called `rs485_DE` using C. This tool would open the original RS485 port (e.g., `/dev/ttyAMA2`), then create a new virtual serial port, and monitor data on the virtual port. It would then automatically toggle the chip's $\\overline{\\text{RE}}$ pin based on the data flow direction. However, this approach introduced a new issue: the higher baud rates, the more frequently data loss would occurr. The root cause was the tool's reliance on polling to check the buffers, coupled with the use of the `libgpiod` library to manipulate GPIOs for flow control, which was too slow to meet the performance requirements.\n\nAdding to the complexity, the RS485 transceiver chip used in the product was the TPT7487. On this chip, the $\\overline{\\text{RE}}$ pin is responsible for controlling the chip's mode - either receive or transmit. However, instead of being connected to dedicated DTR pins, the $\\overline{\\text{RE}}$ pin was wired to several general-purpose GPIO pins on the Compute Module 4 (CM4). Unfortunately, the kernel driver did not configure these GPIOs as DTR pins, further limiting the ability to implement a hardware-based solution for automatic data direction control.\n\n![The general-purpose GPIO pins to RS485 transceiver chips](https://assets.n0w0n.com/the_60000_usd_patch_is_a_triumph/1.png)\n![The RS485 transceiver schematic](https://assets.n0w0n.com/the_60000_usd_patch_is_a_triumph/2.png)\n\nAfter thorough discussions and evaluations, the team concluded that replacing all affected products was the only viable solution. Despite the significant cost - an estimated $60,000 - the company prioritized customer satisfaction and product reliability. With no better technical solution available, the recall decision was made to uphold the company's reputation and ensure long-term trust from customers.\n\nOut of curiosity, I requested the schematic of the product and, after some analysis, I surprisingly discovered what I believed could be a potential software solution to the issues. That marked the beginning of a new chapter in addressing the problem.\n\n\n\n## A Kernel-Level Approach to the Issue\n\nFrom the above schematic and the [TPT7487 datasheet](http://file.3peakic.com.cn:8080/product/Datasheet_TPT7487-TPT7488.pdf), it became clear that when the CM4_RS485_n_DTR (where n = [1, 2, 3]) pins are low, the transceiver enters receive mode; when they are high, the chip switches to transmit mode.\n\nSince this product is based on the CM4, it is highly likely that most users would download and install the official Raspberry Pi OS image, which meant that modifying and redistributing the Raspberry Pi Linux kernel driver would be impractical. This approach would introduce significant inconvenience for users - especially since we don't even have an independent apt source!\n\nNow the problem was clear: a solution that required kernel changes or custom distribution wouldn't work in this environment.\n\nAs I continued to think about the issue, I realized that I could write an out-of-tree kernel module to control the $\\overline{\\text{RE}}$ pin and thus achieve automatic toggling of the transceiver mode. However, the challenge was to implement this solution without relying on polling, which had been a major flaw in the original approach. At the time, I didn't have much experience with kernel modules, but I decided to take a chance and try to solve it.\n\nI recalled an idea I had seen previously in server monitoring tools, where file changes could be tracked by hooking into the syscall layer. Inspired by this concept, I figured I could apply the same principle to monitor the UART calls and control the $\\overline{\\text{RE}}$ pin's state. Instead of polling, I thought I could hook into the relevant functions that handle data transmission and reception, allowing me to change the pin's state dynamically in response to the data flow direction.\n\nBy leveraging this approach, I aimed to develop a solution that was both efficient and non-intrusive, providing a clean software-level fix without needing to modify the underlying kernel or disrupt the user experience.\n\n## The Challenges with Kernel Modifications\n\nAs I began exploring potential solutions to hook syscalls, I encountered a significant challenge with the existing syscall hook implementations. Many of the examples I found were designed for kernel versions prior to 5.7. This limitation stemmed from the fact that, starting from kernel 5.7, the `kallsyms_lookup_name` function was no longer exported, which meant the approach of directly searching for kernel symbols by name wouldn't work.\n\nAfter researching alternatives, I discovered that the kprobe mechanism could be used to achieve the same goal. The kprobe is a powerful tool in the Linux kernel that allows for dynamic instrumentation of functions at runtime. By using kprobe, I could locate and interact with kernel symbols (such as syscalls) even on newer kernels where `kallsyms_lookup_name` is not available. This discovery provided a way to work around the limitations of newer kernel versions.\n\nWith this in mind, I proceeded to write a kernel module to implement syscall hooking using kprobe. The following code demonstrates how to hook the `mkdir` syscall, replacing it with a custom version. The module dynamically locates kernel symbols using kprobe, bypassing the restriction imposed by kernel 5.7 and above.\n\nBTW, The following code is designed to work with ARM64 architecture. For x86_64 architecture, [the full demo has been provided on GitHub](https://github.com/bclswl0827/linux-syscall-hook-mkdir/tree/master).\n\n```cpp\n#include <asm/unistd.h>\n#include <linux/kallsyms.h>\n#include <linux/kernel.h>\n#include <linux/kprobes.h>\n#include <linux/module.h>\n#include <linux/version.h>\n#include <linux/vmalloc.h>\n\n#define MODULE_NAME \"syscall_hook\"\n#define LOG_PREFIX MODULE_NAME \": \"\n\nMODULE_DESCRIPTION(\"A simple module that hooks the `mkdir` function, works on kernel 5.7 and higher.\");\nMODULE_AUTHOR(\"Joshua Lee <chengxun.li@seeed.cc>\");\nMODULE_LICENSE(\"Dual MIT/GPL\");\nMODULE_VERSION(\"0.0.1\");\n\n// For Linux 5.7 and higher versions, `kallsyms_lookup_name` is not exported anymore.\n// But we can use `kprobe` to find the address of `kallsyms_lookup_name`.\n// The `custom_kallsyms_lookup_name` represents the address of `kallsyms_lookup_name` internally.\n// For kernel 5.7 and below, the `custom_kallsyms_lookup_name` simply calls to `kallsyms_lookup_name`.\n#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 7, 0)\ntypedef unsigned long (*kallsyms_lookup_name_t)(const char* name);\nstatic kallsyms_lookup_name_t custom_kallsyms_lookup_name;\n#else\n#define custom_kallsyms_lookup_name kallsyms_lookup_name\n#endif\n\n// `fixup_kallsyms_lookup_name` extracts the address of `kallsyms_lookup_name` from `kprobe`.\n// It returns 0 on success, -EFAULT on failure.\nstatic int fixup_kallsyms_lookup_name(void) {\n#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 7, 0)\n    struct kprobe kp = {.symbol_name = \"kallsyms_lookup_name\"};\n    int result = register_kprobe(&kp);\n    if (result < 0) {\n        printk(KERN_ERR LOG_PREFIX \"Failed to register kprobe, returned code: %d\\n\", result);\n        return result;\n    }\n    custom_kallsyms_lookup_name = (kallsyms_lookup_name_t)kp.addr;\n    unregister_kprobe(&kp);\n    if (!custom_kallsyms_lookup_name) {\n        printk(KERN_ERR LOG_PREFIX \"Failed to get address for `kallsyms_lookup_name`\\n\");\n        return -EFAULT;\n    }\n    printk(KERN_DEBUG LOG_PREFIX \"Got address for `kallsyms_lookup_name`: %p\\n\", custom_kallsyms_lookup_name);\n    return 0;\n#else\n    return 0;\n#endif\n}\n\nstruct vm_struct* (*custom_find_vm_area)(const void* base_addr);      // `custom_find_vm_area` points to the address of `find_vm_area` function.\nint (*custom_set_memory_rw)(unsigned long base_addr, int num_pages);  // `custom_set_memory_rw` points to the address of `set_memory_rw` function.\nint (*custom_set_memory_ro)(unsigned long base_addr, int num_pages);  // `custom_set_memory_ro` points to the address of `set_memory_ro` function.\nstatic unsigned long syscall_target_base_addr;                        // `syscall_target_base_addr` is the base address of target syscall.\n\ntypedef long (*syscall_fn_t)(const struct pt_regs* regs);  // `syscall_fn_t` is the type of any syscall.\nstatic syscall_fn_t prototype_mkdir;                       // `prototype_mkdir` is backup of original `mkdir` function.\nstatic unsigned long* syscall_table;                       // `syscall_table` points to the address of `sys_call_table`.\n\n// `custom_mkdir` is our custom `mkdir` function.\n// Do whatever you want here and return the result.\nstatic int custom_mkdir(const struct pt_regs* regs) {\n    char filename[512] = {0};\n    char __user* pathname = (char*)regs->regs[1];\n    if (copy_from_user(filename, pathname, sizeof(filename)) != 0) {\n        printk(KERN_ERR LOG_PREFIX \"Failed to get file name from user\\n\");\n        return -1;\n    }\n    printk(KERN_INFO LOG_PREFIX \"`mkdir` function called by user, file name: %s\\n\", filename);\n    return prototype_mkdir(regs);  // Call original `mkdir`.\n}\n\nstatic int module_init_fn(void) {\n    if (fixup_kallsyms_lookup_name() < 0) {\n        return -1;\n    }\n\n    custom_set_memory_ro = (void*)custom_kallsyms_lookup_name(\"set_memory_ro\");\n    if (custom_set_memory_ro == NULL) {\n        printk(KERN_ERR LOG_PREFIX \"Could not find `set_memory_ro`\\n\");\n        return -1;\n    }\n\n    custom_set_memory_rw = (void*)custom_kallsyms_lookup_name(\"set_memory_rw\");\n    if (custom_set_memory_rw == NULL) {\n        printk(KERN_ERR LOG_PREFIX \"Could not find `set_memory_rw`\\n\");\n        return -1;\n    }\n\n    custom_find_vm_area = (void*)custom_kallsyms_lookup_name(\"find_vm_area\");\n    if (custom_find_vm_area == NULL) {\n        printk(KERN_ERR LOG_PREFIX \"Could not find `find_vm_area`\\n\");\n        return -1;\n    }\n\n    syscall_table = (unsigned long*)custom_kallsyms_lookup_name(\"sys_call_table\");\n    if (syscall_table == NULL) {\n        printk(KERN_ERR LOG_PREFIX \"Could not find `sys_call_table`\\n\");\n        return -1;\n    }\n    prototype_mkdir = (syscall_fn_t)syscall_table[__NR_mkdirat];  // Create backup of original `mkdir` function.\n\n    syscall_target_base_addr = ((unsigned long)(syscall_table + __NR_mkdirat)) & PAGE_MASK;\n    struct vm_struct* area = custom_find_vm_area((void*)syscall_target_base_addr);\n    if (area == NULL) {\n        printk(KERN_ERR LOG_PREFIX \"Could not find vm area\\n\");\n        return -1;\n    }\n    area->flags |= VM_ALLOC;\n\n    int result = custom_set_memory_rw(syscall_target_base_addr, 1);\n    if (result != 0) {\n        printk(KERN_ERR LOG_PREFIX \"Failed to set memory to read/write mode\\n\");\n        return -1;\n    }\n    syscall_table[__NR_mkdirat] = (unsigned long)custom_mkdir;  // Replace original `mkdir` with our custom one.\n    result = custom_set_memory_ro(syscall_target_base_addr, 1);\n    if (result != 0) {\n        printk(KERN_ERR LOG_PREFIX \"Failed to set memory to read-only mode\\n\");\n        return -1;\n    }\n\n    printk(KERN_INFO LOG_PREFIX \"Hooked `mkdir` function successfully (%p => %p)\\n\", prototype_mkdir, custom_mkdir);\n    return 0;\n}\n\nstatic void module_end_fn(void) {\n    int result = custom_set_memory_rw(syscall_target_base_addr, 1);\n    if (result != 0) {\n        printk(KERN_ERR LOG_PREFIX \"Failed to set memory to read/write mode\\n\");\n        return;\n    }\n    syscall_table[__NR_mkdirat] = (unsigned long)prototype_mkdir;  // Restore original `mkdir` function.\n    result = custom_set_memory_ro(syscall_target_base_addr, 1);\n    if (result != 0) {\n        printk(KERN_ERR LOG_PREFIX \"Failed to set memory to read-only mode\\n\");\n        return;\n    }\n\n    printk(KERN_INFO LOG_PREFIX \"Unhooked `mkdir` function successfully (%p => %p)\\n\", custom_mkdir, prototype_mkdir);\n}\n\nmodule_init(module_init_fn);\nmodule_exit(module_end_fn);\n```\n\n![Hook loaded](https://assets.n0w0n.com/the_60000_usd_patch_is_a_triumph/3.png)\n\nCheers!\n\n## Happy Hacking with Kprobes\n\nOver the next few days, I broke down the task into smaller steps and gradually implemented the required functionality:\n\n1. Set GPIO Mode and Control Pin Levels in the Kernel Module\n2. Hook `uart_write` in the Kernel Module to Raise GPIO Before Transmission\n3. Wait for `uart_write` Completion and Lower GPIO After Transmission\n\n[Thanks to an article I wrote in 2023 on using mmap for GPIO control](https://n0w0n.com/#/post/allwinner_h3_memory_mapping), I successfully implemented GPIO control in a Raspberry Pi kernel module. The final code is as follows, [I also made it public on my GitHub repository](https://github.com/bclswl0827/r1000v1-rs485-autoflow).\n\n```cpp\n#include <asm/io.h>\n#include <linux/delay.h>\n#include <linux/kprobes.h>\n#include <linux/slab.h>\n#include <linux/tty.h>\n#include <linux/workqueue.h>\n\n#ifndef MODULE_NAME\n#define MODULE_NAME \"r1000v1_rs485_autoflow\"\n#endif\n\n#ifndef MODULE_VER\n#define MODULE_VER \"custom\"\n#endif\n\nMODULE_DESCRIPTION(\"This module fixes RS-485 flow control issue on reComputer R1000 v1.0 by hooking `uart_write` function.\");\nMODULE_AUTHOR(\"Joshua Lee <chengxun.li@seeed.cc>\");\nMODULE_LICENSE(\"Dual MIT/GPL\");\nMODULE_VERSION(MODULE_VER);\n\n#define BCM2711_GPIO_BASE (0xfe000000 + 0x200000)\n\nvolatile unsigned int* GPFSEL0;                  // Function selector for GPIO 0-9, for CM4_RS485_1_DTR at GPIO_6.\nvolatile unsigned int* GPFSEL1;                  // Function selector for GPIO 10-19, for CM4_RS485_2_DTR at GPIO_17.\nvolatile unsigned int* GPFSEL2;                  // Function selector for GPIO 20-29, for CM4_RS485_3_DTR at GPIO_24.\nvolatile unsigned int* GPSET0;                   // Register to set GPIO 0-31 to high.\nvolatile unsigned int* GPCLR0;                   // Register to set GPIO 0-31 to low.\nvolatile unsigned int* GPIO_PUP_PDN_CNTRL_REG0;  // Register to set pull up/down control of GPIO 0-15.\nvolatile unsigned int* GPIO_PUP_PDN_CNTRL_REG1;  // Register to set pull up/down control of GPIO 16-31.\n\nstatic void rs485_dtr_init(void) {\n    // Re-map GPIO registers, offsets are given in the datasheet\n    GPFSEL0 = (volatile unsigned int*)ioremap(BCM2711_GPIO_BASE + 0x00, 4);\n    GPFSEL1 = (volatile unsigned int*)ioremap(BCM2711_GPIO_BASE + 0x04, 4);\n    GPFSEL2 = (volatile unsigned int*)ioremap(BCM2711_GPIO_BASE + 0x08, 4);\n    GPSET0 = (volatile unsigned int*)ioremap(BCM2711_GPIO_BASE + 0x1c, 4);\n    GPCLR0 = (volatile unsigned int*)ioremap(BCM2711_GPIO_BASE + 0x28, 4);\n    GPIO_PUP_PDN_CNTRL_REG0 = (volatile unsigned int*)ioremap(BCM2711_GPIO_BASE + 0xe4, 4);\n    GPIO_PUP_PDN_CNTRL_REG1 = (volatile unsigned int*)ioremap(BCM2711_GPIO_BASE + 0xe8, 4);\n\n    // Set CM4_RS485_1_DTR at GPIO_6 to output mode (GPFSEL0[20:18]), no internal pull\n    *GPFSEL0 &= ~(7 << 18);\n    *GPFSEL0 |= (1 << 18);\n    *GPIO_PUP_PDN_CNTRL_REG0 &= ~(3 << 12);\n    *GPIO_PUP_PDN_CNTRL_REG0 |= (0 << 12);\n    // Set CM4_RS485_2_DTR at GPIO_17 to output mode (GPFSEL1[23:21]), no internal pull\n    *GPFSEL1 &= ~(7 << 21);\n    *GPFSEL1 |= (1 << 21);\n    *GPIO_PUP_PDN_CNTRL_REG1 &= ~(3 << 2);\n    *GPIO_PUP_PDN_CNTRL_REG1 |= (0 << 2);\n    // Set CM4_RS485_3_DTR at GPIO_24 to output mode (GPFSEL2[14:12]), no internal pull\n    *GPFSEL2 &= ~(7 << 12);\n    *GPFSEL2 |= (1 << 12);\n    *GPIO_PUP_PDN_CNTRL_REG1 &= ~(3 << 16);\n    *GPIO_PUP_PDN_CNTRL_REG1 |= (0 << 16);\n    // Set all DTR pins to low\n    *GPCLR0 = (1 << 6) | (1 << 17) | (1 << 24);\n}\n\nstatic void rs485_dtr_deinit(void) {\n    // Set all DTR pins to low\n    *GPCLR0 = (1 << 6) | (1 << 17) | (1 << 24);\n    // Unmap GPIO registers\n    iounmap(GPFSEL0);\n    iounmap(GPFSEL1);\n    iounmap(GPFSEL2);\n    iounmap(GPSET0);\n    iounmap(GPCLR0);\n    iounmap(GPIO_PUP_PDN_CNTRL_REG0);\n    iounmap(GPIO_PUP_PDN_CNTRL_REG1);\n}\n\nstatic bool rs485_is_builtin_dev(struct tty_struct* tty) {\n    // `ttyAMA` is for built-in RS-485 interface\n    return strcmp(tty->driver->name, \"ttyAMA\") == 0;\n}\n\nstatic void rs485_dtr_set(int dev_num, bool enable) {\n    switch (dev_num) {\n        case 2:  // ttyAMA2\n            if (enable) {\n                *GPSET0 = (1 << 6);\n            } else {\n                *GPCLR0 = (1 << 6);\n            }\n            break;\n        case 3:  // ttyAMA3\n            if (enable) {\n                *GPSET0 = (1 << 17);\n            } else {\n                *GPCLR0 = (1 << 17);\n            }\n            break;\n        case 5:  // ttyAMA5\n            if (enable) {\n                *GPSET0 = (1 << 24);\n            } else {\n                *GPCLR0 = (1 << 24);\n            }\n            break;\n    }\n}\n\nstatic int rs485_get_dev_num(struct tty_struct* tty) {\n    if (tty->index == 2 || tty->index == 3 || tty->index == 5) {\n        return tty->index;\n    }\n    return -EINVAL;\n}\n\nstruct rs485_worker_t {\n    struct delayed_work work;\n    struct tty_struct* tty;\n};\nstatic struct workqueue_struct* rs485_worker_queues[3];  // 3 queues for 3 RS-485 interfaces (ttyAMA2, ttyAMA3, ttyAMA5)\n\nstatic int rs485_get_worker_index(int dev_num) {\n    if (dev_num == 2) {\n        return 0;\n    } else if (dev_num == 3) {\n        return 1;\n    } else if (dev_num == 5) {\n        return 2;\n    }\n    return -EINVAL;\n}\n\nstatic void rs485_worker_oncomplete(struct work_struct* work) {\n    struct rs485_worker_t* rs485_worker = container_of(work, struct rs485_worker_t, work.work);\n    // Wait until data is sent out, then set DTR to low\n    if (rs485_worker->tty->ops->write_room(rs485_worker->tty) == 0) {\n        schedule_delayed_work(&rs485_worker->work, usecs_to_jiffies(1));\n        return;\n    }\n\n    // Wait for some time before setting DTR to low, delay is based on baudrate\n    // Each character takes (10 * 1000 / baudrate) milliseconds\n    // Plus 60ns for transceiver mode switch (mentionned in TPT7487 datasheet) \n    int baudrate = tty_get_baud_rate(rs485_worker->tty);\n    msleep((10 * 1000) / baudrate);\n    ndelay(60);\n    rs485_dtr_set(rs485_worker->tty->index, false);\n    kfree(rs485_worker);\n}\n\nstatic void hook_uart_write_onreturn(struct kprobe* p, struct pt_regs* regs, unsigned long flags) {\n    struct tty_struct* tty = (struct tty_struct*)regs->regs[0];\n    if (rs485_is_builtin_dev(tty)) {\n        int dev_num = rs485_get_dev_num(tty);\n        if (dev_num != -EINVAL) {\n            struct rs485_worker_t* rs485_worker = kmalloc(sizeof(*rs485_worker), GFP_KERNEL);\n            rs485_worker->tty = tty;\n            if (rs485_worker) {\n                INIT_DELAYED_WORK(&rs485_worker->work, rs485_worker_oncomplete);\n                int queue_index = rs485_get_worker_index(dev_num);\n                if (queue_index != -EINVAL) {\n                    queue_delayed_work(rs485_worker_queues[queue_index], &rs485_worker->work, 0);\n                }\n            }\n        }\n    }\n}\n\nstatic int hook_uart_write_onstart(struct kprobe* p, struct pt_regs* regs) {\n    struct tty_struct* tty = (struct tty_struct*)regs->regs[0];\n    if (rs485_is_builtin_dev(tty)) {\n        int dev_num = rs485_get_dev_num(tty);\n        rs485_dtr_set(dev_num, true);\n    }\n\n    return 0;\n}\n\nstatic unsigned long get_fn_addr(const char* symbol_name) {\n    struct kprobe temp_kp = {.symbol_name = symbol_name};\n    int ret = register_kprobe(&temp_kp);\n    unsigned long fn_addr = (unsigned long)temp_kp.addr;\n\n    unregister_kprobe(&temp_kp);\n    if (ret < 0) {\n        return ret;\n    }\n    if (temp_kp.addr == NULL) {\n        return -EFAULT;\n    }\n\n    return fn_addr;\n}\n\n#define LOG_PREFIX MODULE_NAME \": \"\nstruct kprobe hook_uart_write;\n\nstatic int module_init_fn(void) {\n    rs485_dtr_init();\n\n    // Create worker queues for each RS-485 interface\n    rs485_worker_queues[0] = create_singlethread_workqueue(MODULE_NAME \"_worker_queue_2\");\n    if (rs485_worker_queues[0] == NULL) {\n        printk(KERN_ERR LOG_PREFIX \"Failed to create worker queue for ttyAMA2\\n\");\n        return -ENOMEM;\n    }\n    rs485_worker_queues[1] = create_singlethread_workqueue(MODULE_NAME \"_worker_queue_3\");\n    if (rs485_worker_queues[1] == NULL) {\n        printk(KERN_ERR LOG_PREFIX \"Failed to create worker queue for ttyAMA3\\n\");\n        return -ENOMEM;\n    }\n    rs485_worker_queues[2] = create_singlethread_workqueue(MODULE_NAME \"_worker_queue_5\");\n    if (rs485_worker_queues[2] == NULL) {\n        printk(KERN_ERR LOG_PREFIX \"Failed to create worker queue for ttyAMA5\\n\");\n        return -ENOMEM;\n    }\n\n    // Hook `uart_write` function\n    unsigned long target_fn_addr = get_fn_addr(\"uart_write\");\n    if (target_fn_addr < 0) {\n        printk(KERN_ERR LOG_PREFIX \"Failed to get address for `uart_write`, returned code: %ld\\n\", target_fn_addr);\n        return target_fn_addr;\n    }\n    hook_uart_write.addr = (kprobe_opcode_t*)target_fn_addr;\n    hook_uart_write.pre_handler = (void*)hook_uart_write_onstart;\n    hook_uart_write.post_handler = (void*)hook_uart_write_onreturn;\n    int ret = register_kprobe(&hook_uart_write);\n    if (ret < 0) {\n        printk(KERN_ERR LOG_PREFIX \"Failed to register kprobe for `uart_write`, returned code: %d\\n\", ret);\n        return ret;\n    }\n\n    printk(KERN_INFO LOG_PREFIX \"RS-485 interface has been hooked successfully\\n\");\n    return 0;\n}\n\nstatic void module_exit_fn(void) {\n    unregister_kprobe(&hook_uart_write);\n    for (int i = 0; i < sizeof(rs485_worker_queues) / sizeof(rs485_worker_queues[0]); i++) {\n        if (rs485_worker_queues[i]) {\n            destroy_workqueue(rs485_worker_queues[i]);\n        }\n    }\n    rs485_dtr_deinit();\n\n    printk(KERN_INFO LOG_PREFIX \"RS-485 interface has been unhooked successfully\\n\");\n}\n\nmodule_init(module_init_fn);\nmodule_exit(module_exit_fn);\n```\n\n## The Result and Thoughts\n\n![The Kernel Module Solution](https://assets.n0w0n.com/the_60000_usd_patch_is_a_triumph/4.gif)\n\nAfter deploying the module and testing extensively across various baud rates, the issue was successfully resolved. There was no need to replace products or recall shipments, saving the company $60,000 and sparing customers from potential inconvenience. Well, the software-level solution proved efficient, effective, and sustainable.\n\nThis experience reaffirmed the importance of thinking creatively when addressing challenges. Even as a newcomer, I was able to leverage open-source tools and innovative thinking to tackle a seemingly insurmountable problem. It’s a reminder that in technology, persistence and curiosity often yield unexpected and rewarding outcomes.\n",
            "url": "https://n0w0n.com/read/the_60000_usd_patch_is_a_triumph.md",
            "title": "The $60,000 Patch: A Newcomer's One-Week Triumph",
            "summary": "\nIn mid-October, after three rounds of assessments and interviews, I finally get a work from a company that specializing in open-source IoT and embedded development.\n\nAs an application engineer at this company, my responsibilities include building libraries, maintaining product documentation on the wiki, and creating customized demos for various edge computing devices. Just a few days into the role, I learned about a legacy issue with one of the products. Specifically, the RS485 interfaces had a critical flaw that prevented the port from properly switching the data direction.\n\nThe R&D team had previously attempted to address this issue at the application layer by developing a utility tool called `rs485_DE` using C. This tool would open the original RS485 port (e.g., `/dev/ttyAMA2`), then create a new virtual serial port, and monitor data on the virtual port. It would then automatically toggle the chip's $\\overline{\\text{RE}}$ pin based on the data flow direction. However, this approach introduced a new issue: the higher baud rates, the more frequently data loss would occurr. The root cause was the tool's reliance on polling to check the buffers, coupled with the use of the `libgpiod` library to manipulate GPIOs for flow control, which was too slow to meet the performance requirements.\n\nAdding to the complexity, the RS485 transceiver chip used in the product was the TPT7487. On this chip, the $\\overline{\\text{RE}}$ pin is responsible for controlling the chip's mode - either receive or transmit. However, instead of being connected to dedicated DTR pins, the $\\overline{\\text{RE}}$ pin was wired to several general-purpose GPIO pins on the Compute Module 4 (CM4). Unfortunately, the kernel driver did not configure these GPIOs as DTR pins, further limiting the ability to implement a hardware-based solution for automatic data direction control.\n\n![The general-purpose GPIO pins to RS485 transceiver chips](https://assets.n0w0n.com/the_60000_usd_patch_is_a_triumph/1.png)\n![The RS485 transceiver schematic](https://assets.n0w0n.com/the_60000_usd_patch_is_a_triumph/2.png)\n\nAfter thorough discussions and evaluations, the team concluded that replacing all affected products was the only viable solution. Despite the significant cost - an estimated $60,000 - the company prioritized customer satisfaction and product reliability. With no better technical solution available, the recall decision was made to uphold the company's reputation and ensure long-term trust from customers.\n\nOut of curiosity, I requested the schematic of the product and, after some analysis, I surprisingly discovered what I believed could be a potential software solution to the issues. That marked the beginning of a new chapter in addressing the problem.\n\n",
            "date_modified": "2025-01-21T01:31:22.000Z"
        },
        {
            "id": "allwinner_h3_memory_mapping",
            "content_html": "\nWhen it comes to control the GPIO pins on a development board, many of developers have tried to access the GPIO pins from the user space (e.g. The `sysfs`). But this approach may not perform well because it's not that fast as you may thought - at least it was vividly reflected in one of my recent needs.\n\nRecently I took over a maker-level project that uses the Raspberry Pi and in the project, the Pi needs to continuously poll the level of a certain output from the FPGA at high speed to determine whether the data is \"ready\". However, as the price of Raspberry Pi rises, I had to consider the affordable alternative, finally I settled on the Orange Pi One, which uses the Allwinner H3 and has a 512 MB of RAM - That's enough for my needs.\n\nIn the original Raspberry Pi implementation for the project, the state of the GPIO pins was obtained directly by accessing the GPIO registers - the memory mapping (mmap), and we know that different SOCs have different internal register sets and addresses, so to port the project to the Allwinner H3, some significant changes in the code were required.\n\nThis article will introduce how I understand the concept of mmap, and how did I analyse the datasheet provided by Allwinner, in the last, I'll provide a complete example of how to use mmap to access GPIO pins in C, Go, and Python.\n\n![Orange Pi One](https://assets.n0w0n.com/allwinner_h3_memory_mapping/1.jpg)\n\n\n\n## The Concept of MMAP\n\nIn simple terms, mmap allows a physical memory region to be mapped to the application's virtual memory space. This enables direct manipulation of CPU registers at the application level.\n\nIn conventional development, we typically use the Linux generic sysfs interface to control GPIOs. Through this interface, GPIOs can be configured to output specific signal levels or read external signals input to the GPIO. However, this method is only suitable for scenarios where speed requirements are not stringent. When high-speed GPIO access is required, the sysfs method becomes inefficient. This is because sysfs relies on file I/O operations for GPIO control. Each operation involves accessing the file system and making system calls, which introduces performance overhead.\n\nTo eliminate this additional performance cost and break through the file I/O bottleneck, an alternative approach is to bypass these layers. The mmap method allows direct operations on GPIOs in physical memory, theoretically achieving faster GPIO access.\n\n## The Principle of Controlling\n\nIt is known that the GPIOs on a development board are essentially part of the CPU pins. Since these pins can be controlled programmatically, there must be corresponding registers within the CPU. These registers are mapped to specific physical address ranges that remain constant. By using mmap to operate on the CPU's internal registers, it becomes possible to control specific GPIOs in this manner.\n\nTo control GPIOs via mmap, the process involves the following 5 steps:\n\n1. Open the `/dev/mem` device file.\n2. Determine the physical address of the GPIO control registers.\n3. Use mmap to map the physical address to user space.\n4. Access the GPIO control registers.\n5. Unmap the mmap region.\n\nAmong these steps, step 2 requires consulting the CPU vendor's datasheet to identify the relevant details.\n\n## Consulting the Datasheet\n\n[The datasheet](https://dl.linux-sunxi.org/H3/Allwinner_H3_Datasheet_V1.0.pdf), provided by Allwinner is an extensive 618 pages, making it impractical to read in full. Instead, relevant sections can be found by using Ctrl + F to search for the following keywords:\n\n- Base Address: Identifies the base address.\n- Register: Provides details on the registers.\n\nAnd the key findings from the datasheet are given as follows:\n\n- CPU Base Address: On page 90, section 4.3.4, Register List, it is mentioned that the base address for all CPU registers is `0x01C20000`.\n- GPIO Base Address: On page 318, section 4.22.1, Port Controller Register List, it is noted that the GPIO base address is `0x01C20800`.\n- The offset between the CPU base address and the GPIO base address is therefore `0x0800`.\n\non page 318, section 4.22.2, at Port Controller Register, the GPIO register configurations are detailed. After excluding interrupt-related registers, the useful registers for GPIO configuration are as follows:\n\n| Register | Offset         | Description                                                                                    | Remarks                                                                                                                            |\n| :------- | :------------- | :--------------------------------------------------------------------------------------------- | :--------------------------------------------------------------------------------------------------------------------------------- |\n| Pn_CFG0  | n\\*0x24 + 0x00 | GPIO_n configuration register 0 for setting up pin mode                                     | First determine the port number (e.g. GPIO_A) and pin number (e.g. 6) for which you want to set the GPIO mode.                     |\n| Pn_CFG1  | n\\*0x24 + 0x04 | GPIO_n configuration register 1 for setting up pin mode                                     | Then in the P<u>n</u> Configure Register <u>x</u> table following this table in the Datasheet, where n = [0...6] and x = [0...3],  |\n| Pn_CFG2  | n\\*0x24 + 0x08 | GPIO_n configuration register 2 for setting up pin mode                                     | find the corresponding \"bit\" and \"value\" for the GPIO mode you want to set.                                                        |\n| Pn_CFG3  | n\\*0x24 + 0x0C | GPIO_n configuration register 3 for setting up pin mode                                     | (The code n mentioned above also refers to one of the GPIO port numbers A, C, D, E, F, G, L)                                       |\n| Pn_DAT   | n\\*0x24 + 0x10 | GPIO_n data register for accessing the state of GPIO pin                                    | In input mode, the corresponding bit indicates the pin status; in output mode, the pin status is the same as the corresponding bit |\n| Pn_DRV0  | n\\*0x24 + 0x14 | GPIO_n drive capability register 0, used to configure the output drive capability of GPIO n |                                                                                                                                    |\n| Pn_DRV1  | n\\*0x24 + 0x18 | GPIO_n drive capability register 1, used to configure the output drive capability of GPIO n |                                                                                                                                    |\n| Pn_PUL0  | n\\*0x24 + 0x1C | GPIO_n Pull-up / Pull-down register 0, used to configure the pull-up / pull-down of GPIO n  |                                                                                                                                    |\n| Pn_PUL1  | n\\*0x24 + 0x20 | GPIO_n Pull-up / Pull-down register 1, used to configure the pull-up / pull-down of GPIO n  |                                                                                                                                    |\n\nAlthough we know the GPIO register base address is `0x01C20800`, specific ports like GPIO_A require knowledge of their offset from the GPIO base address.\n\nFrom page 319 of the datasheet, section 4.22.2.1 (PA Configure Register 0), we learn: GPIO_A registers start at an offset of 0x00 relative to the GPIO base address, the configuration for GPIO_A registers ends at `0x01C20820`, with a total width of 0x20 bytes.\n\nGiven this layout, the following C structure can represent the GPIO register set:\n\n```cpp\ntypedef struct {\n    volatile uint32_t config[4];\n    volatile uint32_t data;\n    volatile uint32_t driver[2];\n    volatile uint32_t pull[2];\n} gpio_t;\n```\n\nIn this structure, the keyword `volatile` tells the compiler that the member variables of this structure may be modified by other threads or interrupts, so the compiler should not optimize this structure.\n\n## Some Examples\n\n### Example 1: Configure GPIO_A20 as an Output and Set High\n\nTo configure GPIO_A20 as an output and drive it high, refer to the following details from the datasheet:\n\n1. GPIO_A20's configuration is located in the PA_CFG2_REG register (bits 20–22). Set its value to `0x01` to configure it as an output.\n2. To output a high signal, set bit 20 in the PA_DATA_REG register to `0x01`.\n\n### Example 2: Configure GPIO_A8 as an Input with Pull-Up Enabled\n\nTo configure GPIO_A8 as an input and enable the pull-up resistor, refer to the following details from the datasheet:\n\n1. GPIO_A8's configuration is located in the PA_CFG1_REG register (bits 0–2). Set its value to `0x00` to configure it as an input.\n2. To enable the pull-up resistor, set bits 16–17 in the PA_PULL0_REG register to `0x01`.\n\n## Practical Demonstration\n\nWith the foundational knowledge covered, we can now write programs to solve the problem.\n\nThese examples demonstrates how to use C, Go, and Python to control GPIO_A21 to toggle an LED and read the level of GPIO_A8. The level of GPIO_A8 is printed to the terminal.\n\nNote: Since GPIO_A8 has pull-up enabled, its default level is high unless the pin is grounded. Similarly, if pull-down is enabled, the default level will be low unless connected to power supply.\n\n### The C Implementation\n\nHere is the C version, where the `gpio_t` structure is the same as defined earlier. The `set_output` function configures the GPIO pin as output mode, the `set_input` function configures the GPIO pin as input mode, the `set_level` function sets the GPIO pin level, and the `get_level` function reads the GPIO pin level.\n\n```cpp\n#include <fcntl.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <sys/mman.h>\n#include <unistd.h>\n\n// GPIO_A configuration register list\n// { Register number, Register bit }\nconst int GPIO_A_CONFIG[22][2] = {\n    {0, 0},   // PA0\n    {0, 4},   // PA1\n    {0, 8},   // PA2\n    {0, 12},  // PA3\n    {0, 16},  // PA4\n    {0, 20},  // PA5\n    {0, 24},  // PA6\n    {0, 28},  // PA7\n\n    {1, 0},   // PA8\n    {1, 4},   // PA9\n    {1, 8},   // PA10\n    {1, 12},  // PA11\n    {1, 16},  // PA12\n    {1, 20},  // PA13\n    {1, 24},  // PA14\n    {1, 28},  // PA15\n\n    {2, 0},   // PA16\n    {2, 4},   // PA17\n    {2, 8},   // PA18\n    {2, 12},  // PA19\n    {2, 16},  // PA20\n    {2, 20},  // PA21\n};\n\n// Base address of registers\n#define ALLWINNER_H3_BASE 0x01C20000\n// Offset of GPIO_A relative to ALLWINNER_H3_BASE\n#define GPIO_PA_OFFSET 0x0800\n// Size of the memory region to be mapped using mmap\n#define MMAP_SIZE 0x1000\n\n// GPIO mode configuration\nenum GPIO_MODE {\n    INPUT = 0,\n    OUTPUT,\n};\n// GPIO level configuration\nenum GPIO_LEVEL {\n    LOW = 0,\n    HIGH,\n};\n// GPIO pull-up/pull-down configuration\nenum GPIO_PULL {\n    PULL_OFF = 0,\n    PULL_UP,\n    PULL_DOWN,\n};\n\n// GPIO port register type\ntypedef struct {\n    volatile uint32_t config[4];\n    volatile uint32_t data;\n    volatile uint32_t driver[2];\n    volatile uint32_t pull[2];\n} gpio_t;\n\n// Configure the specified pin of GPIO_A as output\nvoid set_output(gpio_t* gpio, int pin) {\n    // Get the register number and register bit\n    int reg = GPIO_A_CONFIG[pin][0];\n    int bit = GPIO_A_CONFIG[pin][1];\n    // Clear the previous configuration\n    gpio->config[reg] &= ~(0x0F << bit);\n    // Set as output mode\n    gpio->config[reg] |= (OUTPUT << bit);\n}\n\n// Configure the specified pin of GPIO_A as input\nvoid set_input(gpio_t* gpio, int pin) {\n    // Get the register number and register bit\n    int reg = GPIO_A_CONFIG[pin][0];\n    int bit = GPIO_A_CONFIG[pin][1];\n    // Clear the previous configuration\n    gpio->config[reg] &= ~(0x0F << bit);\n    // Set as input mode\n    gpio->config[reg] |= (INPUT << bit);\n}\n\n// Configure pull-up/pull-down for the specified pin of GPIO_A\nvoid set_pull(gpio_t* gpio, int pin, int pull) {\n    // Get the register number\n    int reg = pin / 16;\n    // Get the register bit\n    int bit = (pin % 16) * 2;\n    // Clear the previous configuration\n    gpio->pull[reg] &= ~(0x03 << bit);\n    // Set pull-up/pull-down configuration\n    gpio->pull[reg] |= (uint32_t)pull << bit;\n}\n\n// Set the level of the specified pin of GPIO_A\nvoid set_level(gpio_t* gpio, int pin, int level) {\n    switch (level) {\n        case HIGH:\n            gpio->data |= (1 << pin);\n            return;\n        case LOW:\n            gpio->data &= ~(1 << pin);\n            return;\n        defaults:\n            return;\n    }\n}\n\n// Read the level of the specified pin of GPIO_A\nint get_level(gpio_t* gpio, int pin) {\n    // Get the register number and register bit\n    int reg = GPIO_A_CONFIG[pin][0];\n    int bit = GPIO_A_CONFIG[pin][1];\n    // Clear the previous configuration\n    gpio->config[reg] &= ~(0x0F << bit);\n    return (gpio->data >> pin) & 0x01;\n}\n\nint main() {\n    // Open /dev/mem device file in read-write mode\n    int mem = open(\"/dev/mem\", O_RDWR | O_SYNC);\n    if (mem < 0) {\n        perror(\"open /dev/mem\");\n        return -1;\n    }\n\n    // Map the register into memory\n    char* reg = (char*)mmap(NULL, MMAP_SIZE, PROT_READ | PROT_WRITE, MAP_SHARED,\n                            mem, ALLWINNER_H3_BASE);\n    if (reg == MAP_FAILED) {\n        perror(\"mmap\");\n        close(mem);\n        return -1;\n    }\n\n    // Apply the offset to the GPIO_A register type\n    gpio_t* gpio = (gpio_t*)&reg[GPIO_PA_OFFSET];\n\n    // Set GPIO_A21 as output\n    set_output(gpio, 21);\n    // Set GPIO_A8 as input\n    set_input(gpio, 8);\n    // Enable pull-up for GPIO_A8\n    set_pull(gpio, 8, PULL_UP);\n\n    // Blink the LED and read the level\n    for (;;) {\n        // Toggle GPIO_A21 LED\n        set_level(gpio, 21, HIGH);\n        usleep(500000);\n        set_level(gpio, 21, LOW);\n        usleep(500000);\n        // Read and print the level of GPIO_A8\n        int level = get_level(gpio, 8);\n        printf(\"GPIO_A8 level: %d\\n\", level);\n    }\n\n    // Unmap the memory\n    munmap(gpio, MMAP_SIZE);\n    close(mem);\n\n    return 0;\n}\n```\n\n### The Go Implementation\n\nHere is the Go language implementation. In this version, memory mapping is performed using the `syscall.Mmap()` and `syscall.Munmap()` functions.\n\nAdditionally, unlike the C version where pointer casting is done with (gpio_t \\*) and dereferencing operators \\*, the Go version uses the `unsafe.Pointer` type and the `unsafe.Pointer()` function for pointer conversion, allowing direct memory address manipulation.\n\n```go\npackage main\n\nimport (\n    \"fmt\"\n    \"os\"\n    \"syscall\"\n    \"time\"\n    \"unsafe\"\n)\n\n// GPIO_A configuration register list\n// { register number, register bit }\nvar GPIO_A_CONFIG = [22][2]int{\n    {0, 0},  // PA0\n    {0, 4},  // PA1\n    {0, 8},  // PA2\n    {0, 12}, // PA3\n    {0, 16}, // PA4\n    {0, 20}, // PA5\n    {0, 24}, // PA6\n    {0, 28}, // PA7\n\n    {1, 0},  // PA8\n    {1, 4},  // PA9\n    {1, 8},  // PA10\n    {1, 12}, // PA11\n    {1, 16}, // PA12\n    {1, 20}, // PA13\n    {1, 24}, // PA14\n    {1, 28}, // PA15\n\n    {2, 0},  // PA16\n    {2, 4},  // PA17\n    {2, 8},  // PA18\n    {2, 12}, // PA19\n    {2, 16}, // PA20\n    {2, 20}, // PA21\n}\n\nconst (\n    // Base address of registers\n    ALLWINNER_H3_BASE = 0x01C20000\n    // Offset of GPIO_A relative to ALLWINNER_H3_BASE\n    GPIO_PA_OFFSET = 0x0800\n    // Size of the region to be mapped when using the mmap function\n    MMAP_SIZE = 0x1000\n)\n\n// GPIO mode configuration\nconst (\n    INPUT  = 0\n    OUTPUT = 1\n)\n\n// GPIO level configuration\nconst (\n    LOW  = 0\n    HIGH = 1\n)\n\n// Pull-up/down configuration\nconst (\n    PULL_OFF  = 0\n    PULL_UP   = 1\n    PULL_DOWN = 2\n)\n\n// GPIO port register type\ntype gpio_t struct {\n    config [4]uint32\n    data   uint32\n    driver [2]uint32\n    pull   [2]uint32\n}\n\nfunc setOutput(gpio *gpio_t, pin int) {\n    // Get the register number and register bit\n    reg := GPIO_A_CONFIG[pin][0]\n    bit := GPIO_A_CONFIG[pin][1]\n    // Clear the original configuration\n    gpio.config[reg] &= ^(0x0F << bit)\n    // Set to output mode\n    gpio.config[reg] |= OUTPUT << bit\n}\n\nfunc setInput(gpio *gpio_t, pin int) {\n    // Get the register number and register bit\n    reg := GPIO_A_CONFIG[pin][0]\n    bit := GPIO_A_CONFIG[pin][1]\n    // Clear the original configuration\n    gpio.config[reg] &= ^(0x0F << bit)\n    // Set to input mode\n    gpio.config[reg] |= INPUT << bit\n}\n\nfunc setPull(gpio *gpio_t, pin, pull int) {\n    // Get the register number\n    reg := pin / 16\n    // Get the register bit\n    bit := (pin % 16) * 2\n    // Clear the original configuration\n    gpio.pull[reg] &= ^(0x03 << bit)\n    // Set pull-up/down\n    gpio.pull[reg] |= uint32(pull) << bit\n}\n\nfunc setLevel(gpio *gpio_t, pin, level int) {\n    switch level {\n    case HIGH:\n        gpio.data |= 1 << pin\n    case LOW:\n        gpio.data &= ^(1 << pin)\n    }\n}\n\nfunc getLevel(gpio *gpio_t, pin int) int {\n    // Get the register number and register bit\n    reg := GPIO_A_CONFIG[pin][0]\n    bit := GPIO_A_CONFIG[pin][1]\n    // Clear the original configuration\n    gpio.config[reg] &= ^(0x0F << bit)\n    return int((gpio.data >> pin) & 0x01)\n}\n\nfunc main() {\n    // Open /dev/mem device file in read-write mode\n    mem, err := os.OpenFile(\"/dev/mem\", os.O_RDWR|os.O_SYNC, 0)\n    if err != nil {\n        fmt.Printf(\"Failed to open /dev/mem: %v\\n\", err)\n        return\n    }\n    defer mem.Close()\n\n    // Map the registers to memory\n    reg, err := syscall.Mmap(int(mem.Fd()), ALLWINNER_H3_BASE, MMAP_SIZE, syscall.PROT_READ|syscall.PROT_WRITE, syscall.MAP_SHARED)\n    if err != nil {\n        fmt.Printf(\"Failed to mmap: %v\\n\", err)\n        return\n    }\n    defer syscall.Munmap(reg)\n\n    // Apply the mapped address offset to the GPIO_A register type\n    gpio := (*gpio_t)(unsafe.Pointer(&reg[GPIO_PA_OFFSET]))\n\n    // Set GPIO_A21 as output mode\n    setOutput(gpio, 21)\n    // Set GPIO_A8 as input mode\n    setInput(gpio, 8)\n    // Enable pull-up for GPIO_A8\n    setPull(gpio, 8, PULL_UP)\n\n    // Blink the LED and read the level\n    for {\n        // Blink the GPIO_A21 LED\n        setLevel(gpio, 21, HIGH)\n        time.Sleep(time.Millisecond * 500)\n        setLevel(gpio, 21, LOW)\n        time.Sleep(time.Millisecond * 500)\n        // Read and print the level of GPIO_A8\n        level := getLevel(gpio, 8)\n        fmt.Printf(\"GPIO_A8 level: %d\\n\", level)\n    }\n}\n```\n\n### The Python Implementation\n\nThe Python implementation is similar to the Go implementation, using the `mmap` library to perform memory mapping and unmapping.\n\n```python\nfrom mmap import mmap, MAP_SHARED, PROT_READ, PROT_WRITE\nfrom os import open, close, O_RDWR, O_SYNC\nfrom ctypes import Structure, c_uint32\nfrom typing import Type\nfrom time import sleep\nfrom sys import exit\n\n# GPIO_A configuration register list\n# { register number, register bit }\nGPIO_A_CONFIG = [\n    [0, 0],  # PA0\n    [0, 4],  # PA1\n    [0, 8],  # PA2\n    [0, 12],  # PA3\n    [0, 16],  # PA4\n    [0, 20],  # PA5\n    [0, 24],  # PA6\n    [0, 28],  # PA7\n    [1, 0],  # PA8\n    [1, 4],  # PA9\n    [1, 8],  # PA10\n    [1, 12],  # PA11\n    [1, 16],  # PA12\n    [1, 20],  # PA13\n    [1, 24],  # PA14\n    [1, 28],  # PA15\n    [2, 0],  # PA16\n    [2, 4],  # PA17\n    [2, 8],  # PA18\n    [2, 12],  # PA19\n    [2, 16],  # PA20\n    [2, 20],  # PA21\n]\n\n# Base address of the registers\nALLWINNER_H3_BASE = 0x01C20000\n# Offset of GPIO_A relative to ALLWINNER_H3_BASE\nGPIO_PA_OFFSET = 0x0800\n# Size of the region to be mapped when using the mmap function\nMMAP_SIZE = 0x1000\n# GPIO mode configuration\nINPUT = 0\nOUTPUT = 1\n# GPIO level configuration\nLOW = 0\nHIGH = 1\n# Pull-up/down configuration\nPULL_OFF = 0\nPULL_UP = 1\nPULL_DOWN = 2\n\n\n# GPIO port register type\nclass gpio_t(Structure):\n    _fields_ = [\n        (\"config\", c_uint32 * 4),\n        (\"data\", c_uint32),\n        (\"driver\", c_uint32 * 2),\n        (\"pull\", c_uint32 * 2),\n    ]\n\n\n# Configure the specified GPIO_A pin as output mode\ndef set_output(gpio: Type[gpio_t], pin: int) -> None:\n    # Get the register number and register bit\n    reg, bit = GPIO_A_CONFIG[pin]\n    # Clear the original configuration\n    gpio.config[reg] &= ~(0x0F << bit)\n    # Set as output mode\n    gpio.config[reg] |= (OUTPUT << bit)\n\n\n# Configure the specified GPIO_A pin as input mode\ndef set_input(gpio: Type[gpio_t], pin: int) -> None:\n    # Get the register number and register bit\n    reg, bit = GPIO_A_CONFIG[pin]\n    # Clear the original configuration\n    gpio.config[reg] &= ~(0x0F << bit)\n    # Set as input mode\n    gpio.config[reg] |= (INPUT << bit)\n\n\n# Configure pull-up/down for the specified GPIO_A pin\ndef set_pull(gpio: Type[gpio_t], pin: int, pull: int) -> None:\n    # Get the register number\n    reg = int(pin / 16)\n    # Get the register bit\n    bit = int((pin % 16) * 2)\n    # Clear the original configuration\n    gpio.pull[reg] &= ~(0x03 << bit)\n    # Set pull-up/down\n    gpio.pull[reg] |= (pull << bit)\n\n\n# Set the level of the specified GPIO_A pin\ndef set_level(gpio: Type[gpio_t], pin: int, level: int) -> None:\n    if level == HIGH:\n        gpio.data |= (1 << pin)\n    elif level == LOW:\n        gpio.data &= ~(1 << pin)\n\n\n# Read the level of the specified GPIO_A pin\ndef get_level(gpio: Type[gpio_t], pin: int) -> int:\n    # Get the register number and register bit\n    reg, bit = GPIO_A_CONFIG[pin]\n    # Clear the original configuration\n    gpio.config[reg] &= ~(0x0F << bit)\n    return (gpio.data >> pin) & 0x01\n\n\ndef main():\n    # Open the /dev/mem device file in read-write mode\n    mem = open(\"/dev/mem\", O_RDWR | O_SYNC)\n    if mem < 0:\n        print(\"Failed to open /dev/mem\")\n        exit(1)\n\n    # Map the registers to memory\n    reg = mmap(\n        mem, MMAP_SIZE, MAP_SHARED,\n        PROT_READ | PROT_WRITE,\n        offset=ALLWINNER_H3_BASE\n    )\n\n    # Apply the mapped address offset to the GPIO_A register type\n    gpio = gpio_t.from_buffer(reg, GPIO_PA_OFFSET)\n\n    # Set GPIO_A21 as output mode\n    set_output(gpio, 21)\n    # Set GPIO_A8 as input mode\n    set_input(gpio, 8)\n    # Enable pull-up for GPIO_A8\n    set_pull(gpio, 8, PULL_UP)\n\n    # Blink the LED and read the level\n    while True:\n        # Blink the GPIO_A21 LED\n        set_level(gpio, 21, HIGH)\n        sleep(0.5)\n        set_level(gpio, 21, LOW)\n        sleep(0.5)\n        # Read and print the level of GPIO_A8\n        level = get_level(gpio, 8)\n        print(\"GPIO_A8 level:\", level)\n\n    # Unmap the memory\n    reg.close()\n    close(mem)\n\n\nif __name__ == \"__main__\":\n    main()\n```\n\n## The Conclusion\n\nLast but not least, we have successfully implemented the memory mapping in the Allwinner H3 platform. It works like magic now!\n\n![GPIO_A21 Blinking LED](https://assets.n0w0n.com/allwinner_h3_memory_mapping/2.gif)\n![Read GPIO_A8 Level](https://assets.n0w0n.com/allwinner_h3_memory_mapping/3.png)\n",
            "url": "https://n0w0n.com/read/allwinner_h3_memory_mapping.md",
            "title": "MMAP on Allwinner H3 - The faster way to access to GPIO pins",
            "summary": "\nWhen it comes to control the GPIO pins on a development board, many of developers have tried to access the GPIO pins from the user space (e.g. The `sysfs`). But this approach may not perform well because it's not that fast as you may thought - at least it was vividly reflected in one of my recent needs.\n\nRecently I took over a maker-level project that uses the Raspberry Pi and in the project, the Pi needs to continuously poll the level of a certain output from the FPGA at high speed to determine whether the data is \"ready\". However, as the price of Raspberry Pi rises, I had to consider the affordable alternative, finally I settled on the Orange Pi One, which uses the Allwinner H3 and has a 512 MB of RAM - That's enough for my needs.\n\nIn the original Raspberry Pi implementation for the project, the state of the GPIO pins was obtained directly by accessing the GPIO registers - the memory mapping (mmap), and we know that different SOCs have different internal register sets and addresses, so to port the project to the Allwinner H3, some significant changes in the code were required.\n\nThis article will introduce how I understand the concept of mmap, and how did I analyse the datasheet provided by Allwinner, in the last, I'll provide a complete example of how to use mmap to access GPIO pins in C, Go, and Python.\n\n![Orange Pi One](https://assets.n0w0n.com/allwinner_h3_memory_mapping/1.jpg)\n\n",
            "date_modified": "2023-05-20T05:08:00.000Z"
        }
    ]
}