{"title":"No C, No Python, No Problem: Writing a SeisComP Plugin in Pure Go","created_at":1758690480000,"updated_at":1758730971590,"content":"\nIt has been a few months since I left Seeed Studio and started working on my own business, [AnyShake Project](https://anyshake.org), a open-source project targeted at Raspberry Shake and other similar products.\n\nAs part of building a complete seismograph solution — both hardware and software — I knew from the beginning that integration with SeisComP was a must. It's one of the most widely used tools in professional seismology for real-time monitoring, data acquisition, and event detection. However, most SeisComP plugins are traditionally written in either C++ or Python. And to be honest, after years of juggling build systems, header hell, and Python dependency management, I decided: not this time.\n\n## The Challenge\n\nSeisComP's plugin system is designed with C, C++, and Python in mind. There's no official plugin SDK for Go — actually, no SDKs at all — and the documentation is painfully sparse when it comes to writing custom data sources.\n\nTo be honest, after getting used to modern developer tools and documentation with quick starts, examples, and real-world use cases, reading the SeisComP docs felt like stepping back in time. Instead of showing you how to get something working quickly, it starts with every possible concept, explained in abstract detail. I get that it's thorough, but when all I wanted was \"how do I feed my waveform into the system?\"—it was a slog.\n\nI don’t need a philosophical discussion on the nature of a stream; I need a working data pipeline.\n\nSo I decided to do it the hard way: dive into the source code, trace how existing modules talk to each other, and build my own minimal setup from scratch.\n\n## Why Go?\n\nGo (or Golang) has become my go-to language for building everything from firmware tools to backend services. It compiles to a single binary, it's cross-platform friendly, and concurrency is baked into the language. Most importantly, it allows me to move fast without sacrificing stability or maintainability. So the question became: can I write a fully functional SeisComP plugin in pure Go—no C bindings, no Python wrappers?\n\n> Spoiler alert: yes, I can.\n\n\n\n## Analysis and Design\n\nSeismograph manufacturers are scattered across the globe, and most of them use their own proprietary protocols. To accommodate this diversity, SeisComP adopts an interface-oriented design pattern: it provides two files, [`plugin.c`](https://github.com/SeisComP/seedlink/blob/master/libs/plugin/plugin.c) and [`plugin.h`](https://github.com/SeisComP/seedlink/blob/master/libs/plugin/plugin.h), allowing users to implement specific function signatures (such as `send_raw3`) themselves. Once implemented, users can register their plugin within SeisComP, enabling dynamic loading of data sources without modifying the SeisComP core.\n\nThis is a particularly clever approach because it elegantly decouples third-party data ingestion from the core system. By examining the source code of `plugin.c`, we can see that the final call chain is as follows:\n\n```\nsend_raw3\n  ↓\n  ├─ Prepare and populate header fields (station, channel, time, correction...)\n  ↓\n  ├─ If no data is available:\n  │     ├─ Send a time packet (PluginRawDataTimePacket)\n  │     └─ Or send a GAP packet (PluginRawDataGapPacket)\n  ↓\n  ├─ Loop and send data in fragments:\n  │     ├─ head.packtype = TimePacket (first packet) / DataPacket (subsequent packets)\n  │     ├─ head.data_size = sample_count\n  │     └─ Call send_packet()\n  │           ↓\n  │           ├─ writen(PLUGIN_FD, head)\n  │           └─ writen(PLUGIN_FD, dataptr)\n  ↓\n  └─ Return the total number of bytes sent\n```\n\nHere, `PLUGIN_FD` is defined as `63` — a predefined constant in SeisComP’s SeedLink plugin system. It represents a special file descriptor used as an IPC \"pipe\" for communication between the plugin and SeisComP.\n\nThis insight reveals an important fact: if we can replicate this process, we can implement a fully functional SeisComP plugin in Go.\n\nIn the case of AnyShake Observer, the software already provides a TCP-based data forwarder. This means that all I need to do is connect to the server, receive and parse the incoming data, and then format and send it according to SeisComP’s expected protocol.\n\n## Implementation\n\nInitially, I considered calling the C functions directly via cgo, but ultimately, due to cross-compilation concerns, I decided to translate the prototypes into pure Go code—after all, they aren’t particularly complex. I created a struct that encapsulates the file descriptor and exposed the following methods:\n\n-   SendRaw3\n-   SendFlush3\n-   SendMSeed\n-   SendMSeed2\n-   SendLog3\n-   SendRawDepoch\n\nThey maintain the same function signatures as in C, but are implemented entirely in pure Go, requiring no cgo support and thus can be called directly from Go. The final code is as follows:\n\n```go\nimport (\n\t\"encoding/binary\"\n\t\"os\"\n\t\"time\"\n)\n\nconst (\n\tPLUGIN_FD             = 63\n\tPLUGIN_MSEED_SIZE     = 512\n\tPLUGIN_MAX_MSG_SIZE   = 448\n\tPLUGIN_MAX_DATA_BYTES = 4000\n)\n\nconst (\n\tPLUGIN_RAW_TIME_PACKET  = 8\n\tPLUGIN_RAW_PACKET       = 9\n\tPLUGIN_RAW_GAP_PACKET   = 10\n\tPLUGIN_RAW_FLUSH_PACKET = 11\n\tPLUGIN_LOG_PACKET       = 12\n\tPLUGIN_MSEED_PACKET     = 13\n)\n\ntype PluginPacketHeader struct {\n\tPackType       uint32\n\tStation        [10]byte\n\tChannel        [10]byte\n\tYear           uint32\n\tYday           uint32\n\tHour           uint32\n\tMinute         uint32\n\tSecond         uint32\n\tUsec           uint32\n\tUsecCorrection int32\n\tTimingQuality  int32\n\tDataSize       int32\n}\n\ntype SeedLinkPluginIPC struct {\n\tfd *os.File\n}\n\nfunc NewSeedlinkPluginIPC() SeedLinkPluginIPC {\n\treturn SeedLinkPluginIPC{\n\t\tfd: os.NewFile(PLUGIN_FD, \"seedlink\"),\n\t}\n}\n\nfunc (s *SeedLinkPluginIPC) sendPacket(head *PluginPacketHeader, data []byte) error {\n\theaderBuf := make([]byte, 60)\n\n\tbinary.LittleEndian.PutUint32(headerBuf[0:4], head.PackType)\n\tcopy(headerBuf[4:14], head.Station[:])\n\tcopy(headerBuf[14:24], head.Channel[:])\n\tbinary.LittleEndian.PutUint32(headerBuf[24:28], head.Year)\n\tbinary.LittleEndian.PutUint32(headerBuf[28:32], head.Yday)\n\tbinary.LittleEndian.PutUint32(headerBuf[32:36], head.Hour)\n\tbinary.LittleEndian.PutUint32(headerBuf[36:40], head.Minute)\n\tbinary.LittleEndian.PutUint32(headerBuf[40:44], head.Second)\n\tbinary.LittleEndian.PutUint32(headerBuf[44:48], head.Usec)\n\tbinary.LittleEndian.PutUint32(headerBuf[48:52], uint32(head.UsecCorrection))\n\tbinary.LittleEndian.PutUint32(headerBuf[52:56], uint32(head.TimingQuality))\n\tbinary.LittleEndian.PutUint32(headerBuf[56:60], uint32(head.DataSize))\n\n\tif _, err := s.fd.Write(headerBuf); err != nil {\n\t\treturn err\n\t}\n\tif data != nil {\n\t\tif _, err := s.fd.Write(data); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}\n\nfunc (s *SeedLinkPluginIPC) isLeap(y int) bool {\n\treturn (y%400 == 0) || (y%4 == 0 && y%100 != 0)\n}\n\nfunc (s *SeedLinkPluginIPC) ldoy(y, m int) int {\n\tdoy := [...]int{0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365}\n\tif s.isLeap(y) && m >= 3 {\n\t\treturn doy[m-1] + 1\n\t}\n\treturn doy[m-1]\n}\n\nfunc (s *SeedLinkPluginIPC) mdy2dy(month, day, year int) int {\n\treturn s.ldoy(year, month) + day - 1\n}\n\nfunc (s *SeedLinkPluginIPC) Close() {\n\t_ = s.fd.Close()\n}\n\nfunc (s *SeedLinkPluginIPC) SendRaw3(station, channel string, t time.Time, usecCorr, timingQuality int, data []int32) error {\n\tconst maxSamplesPerPacket = PLUGIN_MAX_DATA_BYTES / 4 // 4000 / 4 = 1000\n\n\tsent := 0\n\ttotal := len(data)\n\tfirst := true\n\n\tfor sent < total {\n\t\tend := sent + maxSamplesPerPacket\n\t\tif end > total {\n\t\t\tend = total\n\t\t}\n\t\tchunk := data[sent:end]\n\n\t\tvar head PluginPacketHeader\n\t\tcopy(head.Station[:], station)\n\t\tcopy(head.Channel[:], channel)\n\n\t\tif first {\n\t\t\thead.PackType = PLUGIN_RAW_TIME_PACKET\n\t\t\thead.Year = uint32(t.Year())\n\t\t\thead.Yday = uint32(s.mdy2dy(int(t.Month()), t.Day(), t.Year()))\n\t\t\thead.Hour = uint32(t.Hour())\n\t\t\thead.Minute = uint32(t.Minute())\n\t\t\thead.Second = uint32(t.Second())\n\t\t\thead.Usec = uint32(t.Nanosecond() / 1000)\n\t\t\thead.UsecCorrection = int32(usecCorr)\n\t\t\thead.TimingQuality = int32(timingQuality)\n\t\t\tfirst = false\n\t\t} else {\n\t\t\thead.PackType = PLUGIN_RAW_PACKET\n\t\t}\n\n\t\thead.DataSize = int32(len(chunk))\n\n\t\tdataBytes := make([]byte, len(chunk)*4)\n\t\tfor i, v := range chunk {\n\t\t\tbinary.LittleEndian.PutUint32(dataBytes[i*4:(i+1)*4], uint32(v))\n\t\t}\n\n\t\tif err := s.sendPacket(&head, dataBytes); err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tsent = end\n\t}\n\n\treturn nil\n}\n\nfunc (s *SeedLinkPluginIPC) SendFlush3(station, channel string) error {\n\tvar head PluginPacketHeader\n\tcopy(head.Station[:], station)\n\tcopy(head.Channel[:], channel)\n\thead.PackType = PLUGIN_RAW_FLUSH_PACKET\n\thead.DataSize = 0\n\n\treturn s.sendPacket(&head, nil)\n}\n\nfunc (s *SeedLinkPluginIPC) SendMSeed(station string, data []byte) error {\n\tif len(data) != PLUGIN_MSEED_SIZE {\n\t\treturn nil\n\t}\n\n\tvar head PluginPacketHeader\n\tcopy(head.Station[:], station)\n\thead.PackType = PLUGIN_MSEED_PACKET\n\thead.DataSize = int32(len(data))\n\n\treturn s.sendPacket(&head, data)\n}\n\nfunc (s *SeedLinkPluginIPC) SendMSeed2(station, channel string, seq int, data []byte) error {\n\tif len(data) != PLUGIN_MSEED_SIZE {\n\t\treturn nil\n\t}\n\n\tvar head PluginPacketHeader\n\tcopy(head.Station[:], station)\n\tcopy(head.Channel[:], channel)\n\thead.PackType = PLUGIN_MSEED_PACKET\n\thead.TimingQuality = int32(seq)\n\thead.DataSize = int32(len(data))\n\n\treturn s.sendPacket(&head, data)\n}\n\nfunc (s *SeedLinkPluginIPC) SendLog3(station string, t time.Time, msg string) error {\n\tvar head PluginPacketHeader\n\tcopy(head.Station[:], station)\n\thead.PackType = PLUGIN_LOG_PACKET\n\n\thead.Year = uint32(t.Year())\n\thead.Yday = uint32(s.mdy2dy(int(t.Month()), t.Day(), t.Year()))\n\thead.Hour = uint32(t.Hour())\n\thead.Minute = uint32(t.Minute())\n\thead.Second = uint32(t.Second())\n\thead.Usec = uint32(t.Nanosecond() / 1000)\n\n\tdata := []byte(msg)\n\thead.DataSize = int32(len(data))\n\n\treturn s.sendPacket(&head, data)\n}\n\nfunc (s *SeedLinkPluginIPC) SendRawDepoch(station, channel string, depoch float64, usecCorr, timingQuality int, data []int32) error {\n\tsec := int64(depoch)\n\tusec := int((depoch - float64(sec)) * 1e6)\n\tt := time.Unix(sec, int64(usec)*1000).UTC()\n\treturn s.SendRaw3(station, channel, t, usecCorr, timingQuality, data)\n}\n```\n\nIn the AnyShake Project, the AnyShake Explorer — used as a data acquisition device—can experience gradual clock drift due to tiny deviations in its crystal oscillator. To address this, I chose to use `SendMSeed` to provide the data, ensuring that each data packet carries a fully controllable timestamp.\n\nThe function `SendMSeed` only accepts pre-encoded MiniSEED packets, so I leveraged a pure Go MiniSEED encoding library I previously developed for the AnyShake Project, [mseedio](https://github.com/bclswl0827/mseedio), to handle this task.\n\nIt’s important to note that, according to the implementation in `plugin.c`, each MiniSEED packet written to `SendMSeed` must have a length equal to `PLUGIN_MSEED_SIZE`, i.e., 512 bytes. Through extensive testing, I found that MiniSEED packets containing 100 samples are safe. Therefore, I set 100 samples as the upper limit for a single MiniSEED data block. Before encoding, I check the data length and slice it appropriately. I also encapsulated the MiniSEED encoding logic to make it easier to use.\n\n```go\nimport (\n\t\"fmt\"\n\t\"time\"\n\n\t\"github.com/bclswl0827/mseedio\"\n)\n\nconst MINISEED_CHUNK_SAMPLES = 100\n\ntype MiniSeedData struct {\n\tStation    string\n\tNetwork    string\n\tLocation   string\n\tChannel    string\n\tTimestamp  int64\n\tSampleRate int\n\tData       []int32\n}\n\nfunc NewMiniSeedData(timestamp time.Time, station, network, location, channel string, sampleRate int, data []int32) MiniSeedData {\n\treturn MiniSeedData{\n\t\tTimestamp:  timestamp.UnixMilli(),\n\t\tStation:    station,\n\t\tNetwork:    network,\n\t\tLocation:   location,\n\t\tChannel:    channel,\n\t\tSampleRate: sampleRate,\n\t\tData:       data,\n\t}\n}\n\nfunc (m *MiniSeedData) chunkInt32Slice(data []int32, chunkSamples int) [][]int32 {\n\tvar chunks [][]int32\n\n\tfor i := 0; i < len(data); i += chunkSamples {\n\t\tend := min(i+chunkSamples, len(data))\n\t\tchunks = append(chunks, data[i:end])\n\t}\n\n\treturn chunks\n}\n\nfunc (m *MiniSeedData) EncodeChunk(sequenceNumber int) ([][]byte, error) {\n\tdataSpanMs := 1000 / m.SampleRate\n\tvar buf [][]byte\n\n\tfor i, c := range m.chunkInt32Slice(m.Data, MINISEED_CHUNK_SAMPLES) {\n\t\tvar miniseed mseedio.MiniSeedData\n\t\tif err := miniseed.Init(mseedio.STEIM2, mseedio.MSBFIRST); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tstartTime := time.UnixMilli(m.Timestamp + int64(i*MINISEED_CHUNK_SAMPLES*dataSpanMs)).UTC()\n\t\tif err := miniseed.Append(c, &mseedio.AppendOptions{\n\t\t\tChannelCode:    m.Channel,\n\t\t\tStationCode:    m.Station,\n\t\t\tLocationCode:   m.Location,\n\t\t\tNetworkCode:    m.Network,\n\t\t\tSampleRate:     float64(m.SampleRate),\n\t\t\tSequenceNumber: fmt.Sprintf(\"%06d\", sequenceNumber),\n\t\t\tStartTime:      startTime,\n\t\t}); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tfor i := 0; i < len(miniseed.Series); i++ {\n\t\t\tminiseed.Series[i].BlocketteSection.RecordLength = 9\n\t\t}\n\n\t\tmsData, err := miniseed.Encode(mseedio.OVERWRITE, mseedio.MSBFIRST)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tbuf = append(buf, msData)\n\t}\n\n\treturn buf, nil\n}\n```\n\nThe above covers the core code analysis. For establishing the TCP connection, the main program, and some necessary template files, I have open-sourced everything in the [AnyShake Nexus](https://github.com/anyshake/nexus) repository. The code is simple and easy to read, so I won’t go into further detail here.\n\n## Test Result\n\nI configured the AnyShake Nexus plugin as a data source in SeisComP.\n\n![SeisComP Configuration](https://assets.n0w0n.com/seiscomp_plugin_impl_in_go/1.png)\n\nAfter starting the SeedLink module and checking the logs, it is clear that the system correctly recognizes the data stream coming from the plugin.\n\n![SeedLink Module](https://assets.n0w0n.com/seiscomp_plugin_impl_in_go/2.png)\n\nOpening a terminal and running `scrttv` shows the real-time waveform from the plugin—mission accomplished.\n\n![Realtime Waveform](https://assets.n0w0n.com/seiscomp_plugin_impl_in_go/3.png)\n","words":14102}