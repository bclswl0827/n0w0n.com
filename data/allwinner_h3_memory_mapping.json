{"title":"MMAP on Allwinner H3  - The faster way to access to GPIO pins","created_at":1684559280000,"updated_at":1737386398680,"content":"\nWhen it comes to control the GPIO pins on a development board, many of developers have tried to access the GPIO pins from the user space (e.g. The `sysfs`). But this approach may not perform well because it's not that fast as you may thought - at least it was vividly reflected in one of my recent needs.\n\nRecently I took over a maker-level project that uses the Raspberry Pi and in the project, the Pi needs to continuously poll the level of a certain output from the FPGA at high speed to determine whether the data is \"ready\". However, as the price of Raspberry Pi rises, I had to consider the affordable alternative, finally I settled on the Orange Pi One, which uses the Allwinner H3 and has a 512 MB of RAM - That's enough for my needs.\n\nIn the original Raspberry Pi implementation for the project, the state of the GPIO pins was obtained directly by accessing the GPIO registers - the memory mapping (mmap), and we know that different SOCs have different internal register sets and addresses, so to port the project to the Allwinner H3, some significant changes in the code were required.\n\nThis article will introduce how I understand the concept of mmap, and how did I analyse the datasheet provided by Allwinner, in the last, I'll provide a complete example of how to use mmap to access GPIO pins in C, Go, and Python.\n\n![Orange Pi One](https://assets.n0w0n.com/allwinner_h3_memory_mapping/1.jpg)\n\n\n\n## The Concept of MMAP\n\nIn simple terms, mmap allows a physical memory region to be mapped to the application's virtual memory space. This enables direct manipulation of CPU registers at the application level.\n\nIn conventional development, we typically use the Linux generic sysfs interface to control GPIOs. Through this interface, GPIOs can be configured to output specific signal levels or read external signals input to the GPIO. However, this method is only suitable for scenarios where speed requirements are not stringent. When high-speed GPIO access is required, the sysfs method becomes inefficient. This is because sysfs relies on file I/O operations for GPIO control. Each operation involves accessing the file system and making system calls, which introduces performance overhead.\n\nTo eliminate this additional performance cost and break through the file I/O bottleneck, an alternative approach is to bypass these layers. The mmap method allows direct operations on GPIOs in physical memory, theoretically achieving faster GPIO access.\n\n## The Principle of Controlling\n\nIt is known that the GPIOs on a development board are essentially part of the CPU pins. Since these pins can be controlled programmatically, there must be corresponding registers within the CPU. These registers are mapped to specific physical address ranges that remain constant. By using mmap to operate on the CPU's internal registers, it becomes possible to control specific GPIOs in this manner.\n\nTo control GPIOs via mmap, the process involves the following 5 steps:\n\n1. Open the `/dev/mem` device file.\n2. Determine the physical address of the GPIO control registers.\n3. Use mmap to map the physical address to user space.\n4. Access the GPIO control registers.\n5. Unmap the mmap region.\n\nAmong these steps, step 2 requires consulting the CPU vendor's datasheet to identify the relevant details.\n\n## Consulting the Datasheet\n\n[The datasheet](https://dl.linux-sunxi.org/H3/Allwinner_H3_Datasheet_V1.0.pdf), provided by Allwinner is an extensive 618 pages, making it impractical to read in full. Instead, relevant sections can be found by using Ctrl + F to search for the following keywords:\n\n- Base Address: Identifies the base address.\n- Register: Provides details on the registers.\n\nAnd the key findings from the datasheet are given as follows:\n\n- CPU Base Address: On page 90, section 4.3.4, Register List, it is mentioned that the base address for all CPU registers is `0x01C20000`.\n- GPIO Base Address: On page 318, section 4.22.1, Port Controller Register List, it is noted that the GPIO base address is `0x01C20800`.\n- The offset between the CPU base address and the GPIO base address is therefore `0x0800`.\n\non page 318, section 4.22.2, at Port Controller Register, the GPIO register configurations are detailed. After excluding interrupt-related registers, the useful registers for GPIO configuration are as follows:\n\n| Register | Offset         | Description                                                                                    | Remarks                                                                                                                            |\n| :------- | :------------- | :--------------------------------------------------------------------------------------------- | :--------------------------------------------------------------------------------------------------------------------------------- |\n| Pn_CFG0  | n\\*0x24 + 0x00 | GPIO\\_`n` configuration register 0 for setting up pin mode                                     | First determine the port number (e.g. GPIO_A) and pin number (e.g. 6) for which you want to set the GPIO mode.                     |\n| Pn_CFG1  | n\\*0x24 + 0x04 | GPIO\\_`n` configuration register 1 for setting up pin mode                                     | Then in the P<u>n</u> Configure Register <u>x</u> table following this table in the Datasheet, where n = [0...6] and x = [0...3],  |\n| Pn_CFG2  | n\\*0x24 + 0x08 | GPIO\\_`n` configuration register 2 for setting up pin mode                                     | find the corresponding \"bit\" and \"value\" for the GPIO mode you want to set.                                                        |\n| Pn_CFG3  | n\\*0x24 + 0x0C | GPIO\\_`n` configuration register 3 for setting up pin mode                                     | (The code n mentioned above also refers to one of the GPIO port numbers A, C, D, E, F, G, L)                                       |\n| Pn_DAT   | n\\*0x24 + 0x10 | GPIO\\_`n` data register for accessing the state of GPIO pin                                    | In input mode, the corresponding bit indicates the pin status; in output mode, the pin status is the same as the corresponding bit |\n| Pn_DRV0  | n\\*0x24 + 0x14 | GPIO\\_`n` drive capability register 0, used to configure the output drive capability of GPIO n |                                                                                                                                    |\n| Pn_DRV1  | n\\*0x24 + 0x18 | GPIO\\_`n` drive capability register 1, used to configure the output drive capability of GPIO n |                                                                                                                                    |\n| Pn_PUL0  | n\\*0x24 + 0x1C | GPIO\\_`n` Pull-up / Pull-down register 0, used to configure the pull-up / pull-down of GPIO n  |                                                                                                                                    |\n| Pn_PUL1  | n\\*0x24 + 0x20 | GPIO\\_`n` Pull-up / Pull-down register 1, used to configure the pull-up / pull-down of GPIO n  |                                                                                                                                    |\n\nAlthough we know the GPIO register base address is `0x01C20800`, specific ports like GPIO_A require knowledge of their offset from the GPIO base address.\n\nFrom page 319 of the datasheet, section 4.22.2.1 (PA Configure Register 0), we learn: GPIO_A registers start at an offset of 0x00 relative to the GPIO base address, the configuration for GPIO_A registers ends at `0x01C20820`, with a total width of 0x20 bytes.\n\nGiven this layout, the following C structure can represent the GPIO register set:\n\n```cpp\ntypedef struct {\n    volatile uint32_t config[4];\n    volatile uint32_t data;\n    volatile uint32_t driver[2];\n    volatile uint32_t pull[2];\n} gpio_t;\n```\n\nIn this structure, the keyword `volatile` tells the compiler that the member variables of this structure may be modified by other threads or interrupts, so the compiler should not optimize this structure.\n\n## Some Examples\n\n### Example 1: Configure GPIO_A20 as an Output and Set High\n\nTo configure GPIO_A20 as an output and drive it high, refer to the following details from the datasheet:\n\n1. GPIO_A20's configuration is located in the PA_CFG2_REG register (bits 20–22). Set its value to `0x01` to configure it as an output.\n2. To output a high signal, set bit 20 in the PA_DATA_REG register to `0x01`.\n\n### Example 2: Configure GPIO_A8 as an Input with Pull-Up Enabled\n\nTo configure GPIO_A8 as an input and enable the pull-up resistor, refer to the following details from the datasheet:\n\n1. GPIO_A8's configuration is located in the PA_CFG1_REG register (bits 0–2). Set its value to 0x00 to configure it as an input.\n2. To enable the pull-up resistor, set bits 16–17 in the PA_PULL0_REG register to 0x01.\n\n## Practical Demonstration\n\nWith the foundational knowledge covered, we can now write programs to solve the problem.\n\nThese examples demonstrates how to use C, Go, and Python to control GPIO_A21 to toggle an LED and read the level of GPIO_A8. The level of GPIO_A8 is printed to the terminal.\n\nNote: Since GPIO_A8 has pull-up enabled, its default level is high unless the pin is grounded. Similarly, if pull-down is enabled, the default level will be low unless connected to power supply.\n\n### The C Implementation\n\nHere is the C version, where the `gpio_t` structure is the same as defined earlier. The `set_output` function configures the GPIO pin as output mode, the `set_input` function configures the GPIO pin as input mode, the `set_level` function sets the GPIO pin level, and the `get_level` function reads the GPIO pin level.\n\n```cpp\n#include <fcntl.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <sys/mman.h>\n#include <unistd.h>\n\n// GPIO_A configuration register list\n// { Register number, Register bit }\nconst int GPIO_A_CONFIG[22][2] = {\n    {0, 0},   // PA0\n    {0, 4},   // PA1\n    {0, 8},   // PA2\n    {0, 12},  // PA3\n    {0, 16},  // PA4\n    {0, 20},  // PA5\n    {0, 24},  // PA6\n    {0, 28},  // PA7\n\n    {1, 0},   // PA8\n    {1, 4},   // PA9\n    {1, 8},   // PA10\n    {1, 12},  // PA11\n    {1, 16},  // PA12\n    {1, 20},  // PA13\n    {1, 24},  // PA14\n    {1, 28},  // PA15\n\n    {2, 0},   // PA16\n    {2, 4},   // PA17\n    {2, 8},   // PA18\n    {2, 12},  // PA19\n    {2, 16},  // PA20\n    {2, 20},  // PA21\n};\n\n// Base address of registers\n#define ALLWINNER_H3_BASE 0x01C20000\n// Offset of GPIO_A relative to ALLWINNER_H3_BASE\n#define GPIO_PA_OFFSET 0x0800\n// Size of the memory region to be mapped using mmap\n#define MMAP_SIZE 0x1000\n\n// GPIO mode configuration\nenum GPIO_MODE {\n    INPUT = 0,\n    OUTPUT,\n};\n// GPIO level configuration\nenum GPIO_LEVEL {\n    LOW = 0,\n    HIGH,\n};\n// GPIO pull-up/pull-down configuration\nenum GPIO_PULL {\n    PULL_OFF = 0,\n    PULL_UP,\n    PULL_DOWN,\n};\n\n// GPIO port register type\ntypedef struct {\n    volatile uint32_t config[4];\n    volatile uint32_t data;\n    volatile uint32_t driver[2];\n    volatile uint32_t pull[2];\n} gpio_t;\n\n// Configure the specified pin of GPIO_A as output\nvoid set_output(gpio_t* gpio, int pin) {\n    // Get the register number and register bit\n    int reg = GPIO_A_CONFIG[pin][0];\n    int bit = GPIO_A_CONFIG[pin][1];\n    // Clear the previous configuration\n    gpio->config[reg] &= ~(0x0F << bit);\n    // Set as output mode\n    gpio->config[reg] |= (OUTPUT << bit);\n}\n\n// Configure the specified pin of GPIO_A as input\nvoid set_input(gpio_t* gpio, int pin) {\n    // Get the register number and register bit\n    int reg = GPIO_A_CONFIG[pin][0];\n    int bit = GPIO_A_CONFIG[pin][1];\n    // Clear the previous configuration\n    gpio->config[reg] &= ~(0x0F << bit);\n    // Set as input mode\n    gpio->config[reg] |= (INPUT << bit);\n}\n\n// Configure pull-up/pull-down for the specified pin of GPIO_A\nvoid set_pull(gpio_t* gpio, int pin, int pull) {\n    // Get the register number\n    int reg = pin / 16;\n    // Get the register bit\n    int bit = (pin % 16) * 2;\n    // Clear the previous configuration\n    gpio->pull[reg] &= ~(0x03 << bit);\n    // Set pull-up/pull-down configuration\n    gpio->pull[reg] |= (uint32_t)pull << bit;\n}\n\n// Set the level of the specified pin of GPIO_A\nvoid set_level(gpio_t* gpio, int pin, int level) {\n    switch (level) {\n        case HIGH:\n            gpio->data |= (1 << pin);\n            return;\n        case LOW:\n            gpio->data &= ~(1 << pin);\n            return;\n        defaults:\n            return;\n    }\n}\n\n// Read the level of the specified pin of GPIO_A\nint get_level(gpio_t* gpio, int pin) {\n    // Get the register number and register bit\n    int reg = GPIO_A_CONFIG[pin][0];\n    int bit = GPIO_A_CONFIG[pin][1];\n    // Clear the previous configuration\n    gpio->config[reg] &= ~(0x0F << bit);\n    return (gpio->data >> pin) & 0x01;\n}\n\nint main() {\n    // Open /dev/mem device file in read-write mode\n    int mem = open(\"/dev/mem\", O_RDWR | O_SYNC);\n    if (mem < 0) {\n        perror(\"open /dev/mem\");\n        return -1;\n    }\n\n    // Map the register into memory\n    char* reg = (char*)mmap(NULL, MMAP_SIZE, PROT_READ | PROT_WRITE, MAP_SHARED,\n                            mem, ALLWINNER_H3_BASE);\n    if (reg == MAP_FAILED) {\n        perror(\"mmap\");\n        close(mem);\n        return -1;\n    }\n\n    // Apply the offset to the GPIO_A register type\n    gpio_t* gpio = (gpio_t*)&reg[GPIO_PA_OFFSET];\n\n    // Set GPIO_A21 as output\n    set_output(gpio, 21);\n    // Set GPIO_A8 as input\n    set_input(gpio, 8);\n    // Enable pull-up for GPIO_A8\n    set_pull(gpio, 8, PULL_UP);\n\n    // Blink the LED and read the level\n    for (;;) {\n        // Toggle GPIO_A21 LED\n        set_level(gpio, 21, HIGH);\n        usleep(500000);\n        set_level(gpio, 21, LOW);\n        usleep(500000);\n        // Read and print the level of GPIO_A8\n        int level = get_level(gpio, 8);\n        printf(\"GPIO_A8 level: %d\\n\", level);\n    }\n\n    // Unmap the memory\n    munmap(gpio, MMAP_SIZE);\n    close(mem);\n\n    return 0;\n}\n```\n\n### The Go Implementation\n\nHere is the Go language implementation. In this version, memory mapping is performed using the `syscall.Mmap()` and `syscall.Munmap()` functions.\n\nAdditionally, unlike the C version where pointer casting is done with (gpio_t \\*) and dereferencing operators \\*, the Go version uses the `unsafe.Pointer` type and the `unsafe.Pointer()` function for pointer conversion, allowing direct memory address manipulation.\n\n```go\npackage main\n\nimport (\n    \"fmt\"\n    \"os\"\n    \"syscall\"\n    \"time\"\n    \"unsafe\"\n)\n\n// GPIO_A configuration register list\n// { register number, register bit }\nvar GPIO_A_CONFIG = [22][2]int{\n    {0, 0},  // PA0\n    {0, 4},  // PA1\n    {0, 8},  // PA2\n    {0, 12}, // PA3\n    {0, 16}, // PA4\n    {0, 20}, // PA5\n    {0, 24}, // PA6\n    {0, 28}, // PA7\n\n    {1, 0},  // PA8\n    {1, 4},  // PA9\n    {1, 8},  // PA10\n    {1, 12}, // PA11\n    {1, 16}, // PA12\n    {1, 20}, // PA13\n    {1, 24}, // PA14\n    {1, 28}, // PA15\n\n    {2, 0},  // PA16\n    {2, 4},  // PA17\n    {2, 8},  // PA18\n    {2, 12}, // PA19\n    {2, 16}, // PA20\n    {2, 20}, // PA21\n}\n\nconst (\n    // Base address of registers\n    ALLWINNER_H3_BASE = 0x01C20000\n    // Offset of GPIO_A relative to ALLWINNER_H3_BASE\n    GPIO_PA_OFFSET = 0x0800\n    // Size of the region to be mapped when using the mmap function\n    MMAP_SIZE = 0x1000\n)\n\n// GPIO mode configuration\nconst (\n    INPUT  = 0\n    OUTPUT = 1\n)\n\n// GPIO level configuration\nconst (\n    LOW  = 0\n    HIGH = 1\n)\n\n// Pull-up/down configuration\nconst (\n    PULL_OFF  = 0\n    PULL_UP   = 1\n    PULL_DOWN = 2\n)\n\n// GPIO port register type\ntype gpio_t struct {\n    config [4]uint32\n    data   uint32\n    driver [2]uint32\n    pull   [2]uint32\n}\n\nfunc setOutput(gpio *gpio_t, pin int) {\n    // Get the register number and register bit\n    reg := GPIO_A_CONFIG[pin][0]\n    bit := GPIO_A_CONFIG[pin][1]\n    // Clear the original configuration\n    gpio.config[reg] &= ^(0x0F << bit)\n    // Set to output mode\n    gpio.config[reg] |= OUTPUT << bit\n}\n\nfunc setInput(gpio *gpio_t, pin int) {\n    // Get the register number and register bit\n    reg := GPIO_A_CONFIG[pin][0]\n    bit := GPIO_A_CONFIG[pin][1]\n    // Clear the original configuration\n    gpio.config[reg] &= ^(0x0F << bit)\n    // Set to input mode\n    gpio.config[reg] |= INPUT << bit\n}\n\nfunc setPull(gpio *gpio_t, pin, pull int) {\n    // Get the register number\n    reg := pin / 16\n    // Get the register bit\n    bit := (pin % 16) * 2\n    // Clear the original configuration\n    gpio.pull[reg] &= ^(0x03 << bit)\n    // Set pull-up/down\n    gpio.pull[reg] |= uint32(pull) << bit\n}\n\nfunc setLevel(gpio *gpio_t, pin, level int) {\n    switch level {\n    case HIGH:\n        gpio.data |= 1 << pin\n    case LOW:\n        gpio.data &= ^(1 << pin)\n    }\n}\n\nfunc getLevel(gpio *gpio_t, pin int) int {\n    // Get the register number and register bit\n    reg := GPIO_A_CONFIG[pin][0]\n    bit := GPIO_A_CONFIG[pin][1]\n    // Clear the original configuration\n    gpio.config[reg] &= ^(0x0F << bit)\n    return int((gpio.data >> pin) & 0x01)\n}\n\nfunc main() {\n    // Open /dev/mem device file in read-write mode\n    mem, err := os.OpenFile(\"/dev/mem\", os.O_RDWR|os.O_SYNC, 0)\n    if err != nil {\n        fmt.Printf(\"Failed to open /dev/mem: %v\\n\", err)\n        return\n    }\n    defer mem.Close()\n\n    // Map the registers to memory\n    reg, err := syscall.Mmap(int(mem.Fd()), ALLWINNER_H3_BASE, MMAP_SIZE, syscall.PROT_READ|syscall.PROT_WRITE, syscall.MAP_SHARED)\n    if err != nil {\n        fmt.Printf(\"Failed to mmap: %v\\n\", err)\n        return\n    }\n    defer syscall.Munmap(reg)\n\n    // Apply the mapped address offset to the GPIO_A register type\n    gpio := (*gpio_t)(unsafe.Pointer(&reg[GPIO_PA_OFFSET]))\n\n    // Set GPIO_A21 as output mode\n    setOutput(gpio, 21)\n    // Set GPIO_A8 as input mode\n    setInput(gpio, 8)\n    // Enable pull-up for GPIO_A8\n    setPull(gpio, 8, PULL_UP)\n\n    // Blink the LED and read the level\n    for {\n        // Blink the GPIO_A21 LED\n        setLevel(gpio, 21, HIGH)\n        time.Sleep(time.Millisecond * 500)\n        setLevel(gpio, 21, LOW)\n        time.Sleep(time.Millisecond * 500)\n        // Read and print the level of GPIO_A8\n        level := getLevel(gpio, 8)\n        fmt.Printf(\"GPIO_A8 level: %d\\n\", level)\n    }\n}\n```\n\n### The Python Implementation\n\nThe Python implementation is similar to the Go implementation, using the `mmap` library to perform memory mapping and unmapping.\n\n```python\nfrom mmap import mmap, MAP_SHARED, PROT_READ, PROT_WRITE\nfrom os import open, close, O_RDWR, O_SYNC\nfrom ctypes import Structure, c_uint32\nfrom typing import Type\nfrom time import sleep\nfrom sys import exit\n\n# GPIO_A configuration register list\n# { register number, register bit }\nGPIO_A_CONFIG = [\n    [0, 0],  # PA0\n    [0, 4],  # PA1\n    [0, 8],  # PA2\n    [0, 12],  # PA3\n    [0, 16],  # PA4\n    [0, 20],  # PA5\n    [0, 24],  # PA6\n    [0, 28],  # PA7\n    [1, 0],  # PA8\n    [1, 4],  # PA9\n    [1, 8],  # PA10\n    [1, 12],  # PA11\n    [1, 16],  # PA12\n    [1, 20],  # PA13\n    [1, 24],  # PA14\n    [1, 28],  # PA15\n    [2, 0],  # PA16\n    [2, 4],  # PA17\n    [2, 8],  # PA18\n    [2, 12],  # PA19\n    [2, 16],  # PA20\n    [2, 20],  # PA21\n]\n\n# Base address of the registers\nALLWINNER_H3_BASE = 0x01C20000\n# Offset of GPIO_A relative to ALLWINNER_H3_BASE\nGPIO_PA_OFFSET = 0x0800\n# Size of the region to be mapped when using the mmap function\nMMAP_SIZE = 0x1000\n# GPIO mode configuration\nINPUT = 0\nOUTPUT = 1\n# GPIO level configuration\nLOW = 0\nHIGH = 1\n# Pull-up/down configuration\nPULL_OFF = 0\nPULL_UP = 1\nPULL_DOWN = 2\n\n\n# GPIO port register type\nclass gpio_t(Structure):\n    _fields_ = [\n        (\"config\", c_uint32 * 4),\n        (\"data\", c_uint32),\n        (\"driver\", c_uint32 * 2),\n        (\"pull\", c_uint32 * 2),\n    ]\n\n\n# Configure the specified GPIO_A pin as output mode\ndef set_output(gpio: Type[gpio_t], pin: int) -> None:\n    # Get the register number and register bit\n    reg, bit = GPIO_A_CONFIG[pin]\n    # Clear the original configuration\n    gpio.config[reg] &= ~(0x0F << bit)\n    # Set as output mode\n    gpio.config[reg] |= (OUTPUT << bit)\n\n\n# Configure the specified GPIO_A pin as input mode\ndef set_input(gpio: Type[gpio_t], pin: int) -> None:\n    # Get the register number and register bit\n    reg, bit = GPIO_A_CONFIG[pin]\n    # Clear the original configuration\n    gpio.config[reg] &= ~(0x0F << bit)\n    # Set as input mode\n    gpio.config[reg] |= (INPUT << bit)\n\n\n# Configure pull-up/down for the specified GPIO_A pin\ndef set_pull(gpio: Type[gpio_t], pin: int, pull: int) -> None:\n    # Get the register number\n    reg = int(pin / 16)\n    # Get the register bit\n    bit = int((pin % 16) * 2)\n    # Clear the original configuration\n    gpio.pull[reg] &= ~(0x03 << bit)\n    # Set pull-up/down\n    gpio.pull[reg] |= (pull << bit)\n\n\n# Set the level of the specified GPIO_A pin\ndef set_level(gpio: Type[gpio_t], pin: int, level: int) -> None:\n    if level == HIGH:\n        gpio.data |= (1 << pin)\n    elif level == LOW:\n        gpio.data &= ~(1 << pin)\n\n\n# Read the level of the specified GPIO_A pin\ndef get_level(gpio: Type[gpio_t], pin: int) -> int:\n    # Get the register number and register bit\n    reg, bit = GPIO_A_CONFIG[pin]\n    # Clear the original configuration\n    gpio.config[reg] &= ~(0x0F << bit)\n    return (gpio.data >> pin) & 0x01\n\n\ndef main():\n    # Open the /dev/mem device file in read-write mode\n    mem = open(\"/dev/mem\", O_RDWR | O_SYNC)\n    if mem < 0:\n        print(\"Failed to open /dev/mem\")\n        exit(1)\n\n    # Map the registers to memory\n    reg = mmap(\n        mem, MMAP_SIZE, MAP_SHARED,\n        PROT_READ | PROT_WRITE,\n        offset=ALLWINNER_H3_BASE\n    )\n\n    # Apply the mapped address offset to the GPIO_A register type\n    gpio = gpio_t.from_buffer(reg, GPIO_PA_OFFSET)\n\n    # Set GPIO_A21 as output mode\n    set_output(gpio, 21)\n    # Set GPIO_A8 as input mode\n    set_input(gpio, 8)\n    # Enable pull-up for GPIO_A8\n    set_pull(gpio, 8, PULL_UP)\n\n    # Blink the LED and read the level\n    while True:\n        # Blink the GPIO_A21 LED\n        set_level(gpio, 21, HIGH)\n        sleep(0.5)\n        set_level(gpio, 21, LOW)\n        sleep(0.5)\n        # Read and print the level of GPIO_A8\n        level = get_level(gpio, 8)\n        print(\"GPIO_A8 level:\", level)\n\n    # Unmap the memory\n    reg.close()\n    close(mem)\n\n\nif __name__ == \"__main__\":\n    main()\n```\n\n## The Conclusion\n\nLast but not least, we have successfully implemented the memory mapping in the Allwinner H3 platform. It works like magic now!\n\n![GPIO_A21 Blinking LED](https://assets.n0w0n.com/allwinner_h3_memory_mapping/2.gif)\n![Read GPIO_A8 Level](https://assets.n0w0n.com/allwinner_h3_memory_mapping/3.png)\n","words":22818}